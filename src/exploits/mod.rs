mod cms_exploit;
mod cors_exploit;
mod network_exploit;
mod scan_to_exploit;
mod sqli_exploit;
mod ssl_exploit;
mod xss_exploit;

use crate::scanners::Vulnerability;
use crate::utils::error::FortiCoreResult;
use colored::Colorize;
use std::fs;
use std::path::{Path, PathBuf};

pub enum ExploitResult {
    Success {
        vulnerability: Vulnerability,
        details: serde_json::Value,
    },
    Partial {
        vulnerability: Vulnerability,
        details: serde_json::Value,
        reason: String,
    },
    Failed {
        vulnerability: Vulnerability,
        reason: String,
    },
}

pub async fn run_exploit(
    target: &str,
    vuln_id: Option<&str>,
    safe_mode: bool,
    verbose: bool,
    scan_file: Option<&Path>,
) -> FortiCoreResult<()> {
    if verbose {
        println!("Running exploitation module against {}", target);
        if let Some(id) = vuln_id {
            println!("Targeting vulnerability ID: {}", id);
        }
        println!("Safe mode: {}", safe_mode);
    }

    // If a specific vulnerability ID is provided, exploit it directly
    if let Some(id) = vuln_id {
        match id {
            id if id.starts_with("WEB-") => {
                web_exploit(target, id, safe_mode, verbose).await?;
            }
            id if id.starts_with("NET-") => {
                network_exploit::exploit(target, id, safe_mode, verbose).await?;
            }
            id if id.starts_with("SSL-") => {
                ssl_exploit::exploit(target, id, safe_mode, verbose).await?;
            }
            _ => {
                println!("Unsupported vulnerability ID format: {}", id);
            }
        }
    } else {
        // Try to discover vulnerabilities and then exploit them
        println!("No specific vulnerability ID provided. Running discovery and exploitation...");
        discover_and_exploit(target, safe_mode, verbose, scan_file).await?;
    }

    Ok(())
}

async fn web_exploit(
    target: &str,
    vuln_id: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    match vuln_id {
        "WEB-001" | "WEB-004" => {
            xss_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-002" | "WEB-005" => {
            sqli_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-003" => {
            cors_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-CMS-001" => {
            // For CMS exploits, we need to determine the CMS type
            // In a real implementation, this would be extracted from the vulnerability details
            // For now, we'll use "wordpress" as a default for demonstration
            cms_exploit::exploit(target, "wordpress", safe_mode, verbose).await?;
        }
        _ => {
            println!("Unsupported web vulnerability ID: {}", vuln_id);
        }
    }

    Ok(())
}

async fn discover_and_exploit(
    target: &str,
    safe_mode: bool,
    verbose: bool,
    scan_file: Option<&Path>,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Looking for recent scan results to use for exploitation...".yellow()
    );

    // Use provided scan file if available, otherwise try to find one
    let scan_file_path = if let Some(path) = scan_file {
        println!(
            "{} {}",
            "Using provided scan results:".green(),
            path.display()
        );
        Some(path.to_path_buf())
    } else {
        // Check if we can find a recent scan file to use
        find_latest_scan_file(target)?
    };

    if let Some(path) = scan_file_path {
        println!("{} {}", "Using scan results:".green(), path.display());

        // Use scan results to drive exploitation
        scan_to_exploit::exploit_from_scan_results(&path, target, safe_mode, verbose).await?;
    } else {
        println!(
            "{}",
            "No scan results found. Performing a basic scan first...".yellow()
        );

        // Run a basic scan first
        let scan_path = run_basic_scan(target, verbose).await?;

        if let Some(path) = scan_path {
            println!(
                "{} {}",
                "Basic scan completed. Using results from:".green(),
                path.display()
            );

            // Use new scan results to drive exploitation
            scan_to_exploit::exploit_from_scan_results(&path, target, safe_mode, verbose).await?;
        } else {
            println!(
                "{}",
                "Failed to generate scan results. Cannot proceed with exploitation.".red()
            );
        }
    }

    Ok(())
}

// Find the latest scan file for a given target
fn find_latest_scan_file(target: &str) -> FortiCoreResult<Option<PathBuf>> {
    // Check in common scan directories
    let dirs_to_check = vec![
        PathBuf::from("./scans"),
        dirs::home_dir()
            .map(|p| p.join(".forticore").join("scans"))
            .unwrap_or_else(|| PathBuf::from("/")),
        PathBuf::from("/var/lib/forticore/scans"),
    ];

    // Clean target for file search
    let target_clean = target
        .replace("http://", "")
        .replace("https://", "")
        .replace("/", "_")
        .replace(".", "_");

    let mut latest_path: Option<PathBuf> = None;
    let mut latest_modified = std::time::SystemTime::UNIX_EPOCH;

    for dir in dirs_to_check {
        if dir.exists() {
            if let Ok(entries) = fs::read_dir(&dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.is_file() && path.extension().map_or(false, |ext| ext == "json") {
                        // Check if filename contains the target
                        if let Some(filename) = path.file_name().and_then(|n| n.to_str()) {
                            if filename.contains(&target_clean) {
                                // Check if this is more recent than our current latest
                                if let Ok(metadata) = fs::metadata(&path) {
                                    if let Ok(modified) = metadata.modified() {
                                        if modified > latest_modified {
                                            latest_modified = modified;
                                            latest_path = Some(path.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(latest_path)
}

// Run a basic scan to get vulnerabilities for a target
async fn run_basic_scan(target: &str, verbose: bool) -> FortiCoreResult<Option<PathBuf>> {
    use crate::scanners;
    use crate::ScanType;

    // Create directory for scan results
    let scans_dir = PathBuf::from("./scans");
    if let Err(e) = fs::create_dir_all(&scans_dir) {
        eprintln!("Warning: Failed to create scans directory: {}", e);
    }

    // Generate output path
    let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
    let filename = format!(
        "{}_{:?}_{}.json",
        target.replace(".", "_"),
        ScanType::Full,
        timestamp
    );
    let output_path = scans_dir.join(filename);

    println!("Running full scan on target: {}", target);

    // Run the scan
    match scanners::run_scan(
        target,
        &ScanType::Full,
        Some(&output_path),
        verbose,
        true, // Enable subdomain scanning
    )
    .await
    {
        Ok(_) => {
            println!("Scan completed successfully");
            Ok(Some(output_path))
        }
        Err(e) => {
            eprintln!("Scan failed: {}", e);
            Ok(None)
        }
    }
}
