mod cms_exploit;
mod cors_exploit;
mod network_exploit;
mod scan_to_exploit;
mod sqli_exploit;
mod ssl_exploit;
mod xss_exploit;

use crate::scanners::Vulnerability;
use crate::utils::error::FortiCoreResult;
use chrono::Local;
use colored::Colorize;
use serde::Serialize;
use serde_json::json;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

#[derive(Serialize, Clone)]
pub enum ExploitResult {
    Success {
        vulnerability: Vulnerability,
        details: serde_json::Value,
    },
    Partial {
        vulnerability: Vulnerability,
        details: serde_json::Value,
        reason: String,
    },
    Failed {
        vulnerability: Vulnerability,
        reason: String,
    },
}

// Global vector to track all exploit results
static mut EXPLOIT_RESULTS: Option<Vec<ExploitResult>> = None;

// Initialize the exploit results container
pub fn init_exploit_results() {
    unsafe {
        EXPLOIT_RESULTS = Some(Vec::new());
    }
}

// Add an exploit result to the global container
pub fn add_exploit_result(result: ExploitResult) {
    unsafe {
        if let Some(results) = &mut EXPLOIT_RESULTS {
            results.push(result);
        }
    }
}

// Get all exploit results
pub fn get_exploit_results() -> Vec<ExploitResult> {
    unsafe {
        if let Some(results) = &EXPLOIT_RESULTS {
            results.clone()
        } else {
            Vec::new()
        }
    }
}

// Save exploit results to a file
pub fn save_exploit_results(target: &str, output_path: Option<&Path>) -> FortiCoreResult<PathBuf> {
    let results = get_exploit_results();

    // If no results, return early
    if results.is_empty() {
        println!("No exploitation results to save");
        return Ok(PathBuf::new());
    }

    // Determine output path if not provided
    let path = if let Some(p) = output_path {
        p.to_path_buf()
    } else {
        // Create scans directory if it doesn't exist
        let scans_dir = PathBuf::from("exploits");
        if !scans_dir.exists() {
            fs::create_dir_all(&scans_dir)?;
        }

        // Format: exploits/target_YYYYMMDD_HHMMSS.json
        let timestamp = Local::now().format("%Y%m%d_%H%M%S");
        let filename = format!(
            "{}_{}.json",
            target.replace("://", "_").replace('/', "_"),
            timestamp
        );
        scans_dir.join(filename)
    };

    // Create result JSON
    let exploit_result = json!({
        "target": target,
        "timestamp": Local::now().to_rfc3339(),
        "results": results,
        "summary": {
            "total": results.len(),
            "success": results.iter().filter(|r| matches!(r, ExploitResult::Success { .. })).count(),
            "partial": results.iter().filter(|r| matches!(r, ExploitResult::Partial { .. })).count(),
            "failed": results.iter().filter(|r| matches!(r, ExploitResult::Failed { .. })).count(),
        }
    });

    // Write to file
    let results_json = serde_json::to_string_pretty(&exploit_result)?;
    let mut file = File::create(&path)?;
    file.write_all(results_json.as_bytes())?;

    println!("{} {}", "Exploit results saved to:".green(), path.display());

    Ok(path)
}

pub async fn run_exploit(
    target: &str,
    vuln_id: Option<&str>,
    safe_mode: bool,
    verbose: bool,
    scan_file: Option<&Path>,
    output_file: Option<&Path>,
) -> FortiCoreResult<()> {
    // Initialize exploit results container
    init_exploit_results();

    if verbose {
        println!("Running exploitation module against {}", target);
        if let Some(id) = vuln_id {
            println!("Targeting vulnerability ID: {}", id);
        }
        println!("Safe mode: {}", safe_mode);
    }

    // If a specific vulnerability ID is provided, exploit it directly
    if let Some(id) = vuln_id {
        match id {
            id if id.starts_with("WEB-") => {
                web_exploit(target, id, safe_mode, verbose).await?;
            }
            id if id.starts_with("NET-") => {
                network_exploit::exploit(target, id, safe_mode, verbose).await?;
            }
            id if id.starts_with("SSL-") => {
                ssl_exploit::exploit(target, id, safe_mode, verbose).await?;
            }
            _ => {
                println!("Unsupported vulnerability ID format: {}", id);
            }
        }
    } else {
        // Try to discover vulnerabilities and then exploit them
        println!("No specific vulnerability ID provided. Running discovery and exploitation...");
        discover_and_exploit(target, safe_mode, verbose, scan_file).await?;
    }

    // Save the exploit results
    let results_path = save_exploit_results(target, output_file)?;

    // If output file is specified, we should automatically generate a report
    if output_file.is_some() && !results_path.as_os_str().is_empty() {
        println!("Exploitation completed. Results saved.");
    }

    Ok(())
}

async fn web_exploit(
    target: &str,
    vuln_id: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    match vuln_id {
        "WEB-001" | "WEB-004" => {
            xss_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-002" | "WEB-005" => {
            sqli_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-003" => {
            cors_exploit::exploit(target, safe_mode, verbose).await?;
        }
        "WEB-CMS-001" => {
            // For CMS exploits, we need to determine the CMS type
            // In a real implementation, this would be extracted from the vulnerability details
            // For now, we'll use "wordpress" as a default for demonstration
            cms_exploit::exploit(target, "wordpress", safe_mode, verbose).await?;
        }
        _ => {
            println!("Unsupported web vulnerability ID: {}", vuln_id);
        }
    }

    Ok(())
}

async fn discover_and_exploit(
    target: &str,
    safe_mode: bool,
    verbose: bool,
    scan_file: Option<&Path>,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Looking for recent scan results to use for exploitation...".yellow()
    );

    // Use provided scan file if available, otherwise try to find one
    let scan_file_path = if let Some(path) = scan_file {
        println!(
            "{} {}",
            "Using provided scan results:".green(),
            path.display()
        );
        Some(path.to_path_buf())
    } else {
        // Check if we can find a recent scan file to use
        find_latest_scan_file(target)?
    };

    if let Some(path) = scan_file_path {
        println!("{} {}", "Using scan results:".green(), path.display());

        // Use scan results to drive exploitation
        scan_to_exploit::exploit_from_scan_results(&path, target, safe_mode, verbose).await?;
    } else {
        println!(
            "{}",
            "No scan results found. Performing a basic scan first...".yellow()
        );

        // Run a basic scan first
        let scan_path = run_basic_scan(target, verbose).await?;

        if let Some(path) = scan_path {
            println!(
                "{} {}",
                "Basic scan completed. Using results from:".green(),
                path.display()
            );

            // Use new scan results to drive exploitation
            scan_to_exploit::exploit_from_scan_results(&path, target, safe_mode, verbose).await?;
        } else {
            println!(
                "{}",
                "Failed to generate scan results. Cannot proceed with exploitation.".red()
            );
        }
    }

    Ok(())
}

// Find the latest scan file for a given target
fn find_latest_scan_file(target: &str) -> FortiCoreResult<Option<PathBuf>> {
    // Check in common scan directories
    let dirs_to_check = vec![
        PathBuf::from("./scans"),
        dirs::home_dir()
            .map(|p| p.join(".forticore").join("scans"))
            .unwrap_or_else(|| PathBuf::from("/")),
        PathBuf::from("/var/lib/forticore/scans"),
    ];

    // Clean target for file search
    let target_clean = target
        .replace("http://", "")
        .replace("https://", "")
        .replace("/", "_")
        .replace(".", "_");

    let mut latest_path: Option<PathBuf> = None;
    let mut latest_modified = std::time::SystemTime::UNIX_EPOCH;

    for dir in dirs_to_check {
        if dir.exists() {
            if let Ok(entries) = fs::read_dir(&dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.is_file() && path.extension().map_or(false, |ext| ext == "json") {
                        // Check if filename contains the target
                        if let Some(filename) = path.file_name().and_then(|n| n.to_str()) {
                            if filename.contains(&target_clean) {
                                // Check if this is more recent than our current latest
                                if let Ok(metadata) = fs::metadata(&path) {
                                    if let Ok(modified) = metadata.modified() {
                                        if modified > latest_modified {
                                            latest_modified = modified;
                                            latest_path = Some(path.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(latest_path)
}

// Run a basic scan to get vulnerabilities for a target
async fn run_basic_scan(target: &str, verbose: bool) -> FortiCoreResult<Option<PathBuf>> {
    use crate::scanners;
    use crate::ScanType;

    // Create directory for scan results
    let scans_dir = PathBuf::from("./scans");
    if let Err(e) = fs::create_dir_all(&scans_dir) {
        eprintln!("Warning: Failed to create scans directory: {}", e);
    }

    // Generate output path
    let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
    let filename = format!(
        "{}_{:?}_{}.json",
        target.replace(".", "_"),
        ScanType::Full,
        timestamp
    );
    let output_path = scans_dir.join(filename);

    println!("Running full scan on target: {}", target);

    // Run the scan
    match scanners::run_scan(
        target,
        &ScanType::Full,
        Some(&output_path),
        verbose,
        true, // Enable subdomain scanning
    )
    .await
    {
        Ok(_) => {
            println!("Scan completed successfully");
            Ok(Some(output_path))
        }
        Err(e) => {
            eprintln!("Scan failed: {}", e);
            Ok(None)
        }
    }
}
