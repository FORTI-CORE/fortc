use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use reqwest::Client;
use std::io;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio_rustls::rustls::{self, ClientConfig, ServerName};
use tokio_rustls::TlsConnector;

pub async fn exploit(
    target: &str,
    vuln_id: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting SSL/TLS exploitation module...".bright_yellow()
    );

    // Always use safe mode for SSL in production
    if !safe_mode {
        println!(
            "{}",
            "Warning: Even though safe mode is disabled, SSL exploits are always run in safe mode"
                .bright_red()
        );
    }

    // Normalize target for connection
    let (host, port) = normalize_target(target);

    if verbose {
        println!("Targeting host: {}:{}", host, port);
        println!("Vulnerability ID: {}", vuln_id);
    }

    match vuln_id {
        "SSL-001" => exploit_weak_cipher(&host, port, verbose).await?,
        "SSL-002" => exploit_tls_downgrade(&host, port, verbose).await?,
        "SSL-003" => exploit_cert_issues(&host, port, verbose).await?,
        "SSL-004" => exploit_heartbleed(&host, port, verbose).await?,
        _ => {
            println!("Unsupported SSL vulnerability ID: {}", vuln_id);
            return Err(FortiCoreError::ExploitError(format!(
                "Unsupported SSL vulnerability ID: {}",
                vuln_id
            )));
        }
    }

    Ok(())
}

// Normalize target into (host, port) tuple
fn normalize_target(target: &str) -> (String, u16) {
    // Remove protocol prefixes
    let clean_target = target.replace("https://", "").replace("http://", "");

    // Split host and port if present
    if let Some((host, port_str)) = clean_target.split_once(':') {
        if let Ok(port) = port_str.parse::<u16>() {
            return (host.to_string(), port);
        }
    }

    // Default to port 443 if no port specified
    (clean_target.to_string(), 443)
}

// Exploit weak cipher suites
async fn exploit_weak_cipher(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Attempting to exploit weak cipher vulnerability...");

    // Create a custom TLS config supporting outdated/weak ciphers
    let weak_cipher_config = create_weak_cipher_config()?;
    let connector = TlsConnector::from(Arc::new(weak_cipher_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    // Try to connect with weak ciphers
    println!(
        "Attempting connection with weak ciphers to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using weak cipher!".bright_red()
                    );

                    if verbose {
                        // Get connection info
                        if let Some(cipher) = tls_stream.get_ref().1.negotiated_cipher_suite() {
                            println!("Negotiated cipher: {:?}", cipher.suite());
                        }

                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to WEAK CIPHER attack".bright_red()
                    );
                    println!(
                        "This could allow attackers to decrypt traffic or perform MitM attacks."
                    );

                    Ok(())
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with weak ciphers (good)".bright_green()
                    );
                    println!("Server appears to enforce strong cipher usage.");

                    Ok(())
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to weak ciphers.");

                    Ok(())
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit TLS protocol downgrade
async fn exploit_tls_downgrade(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Attempting to exploit TLS downgrade vulnerability...");

    // Create config that only supports SSLv3 and TLS 1.0
    let downgrade_config = create_downgrade_config()?;
    let connector = TlsConnector::from(Arc::new(downgrade_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    println!(
        "Attempting connection with outdated TLS protocols to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using outdated protocol!".bright_red()
                    );

                    if verbose {
                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to POODLE/BEAST attacks".bright_red()
                    );
                    println!("Attackers could potentially exploit this to decrypt sensitive data.");

                    Ok(())
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with outdated protocols (good)".bright_green()
                    );
                    println!("Server requires modern TLS protocol versions.");

                    Ok(())
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to protocol downgrade.");

                    Ok(())
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit certificate issues
async fn exploit_cert_issues(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Checking for certificate validation vulnerabilities...");

    // Create a client that accepts invalid certificates
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .danger_accept_invalid_hostnames(true)
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    // Attempt connection
    let url = format!("https://{}:{}", host, port);

    match client.get(&url).send().await {
        Ok(response) => {
            // Check actual certificate
            println!(
                "{}",
                "Successfully connected with certificate validation disabled".yellow()
            );
            println!("Status: {}", response.status());

            if let Some(certs) = response.remote_addr() {
                println!("Connected to: {}", certs);
            }

            // Attempt connection with normal validation
            let secure_client = Client::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .map_err(|e| {
                    FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
                })?;

            match secure_client.get(&url).send().await {
                Ok(_) => {
                    println!("{}", "Certificate appears valid".bright_green());
                    println!("Server presents a trusted certificate.");
                }
                Err(e) => {
                    println!("{}", "Certificate validation failed".bright_red());
                    println!("Error: {}", e);
                    println!("Server may be using a self-signed or invalid certificate.");
                    println!("This could allow attackers to perform MitM attacks.");
                }
            }

            Ok(())
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {} - {}",
                url, e
            )));
        }
    }
}

// Exploit Heartbleed vulnerability (simulated)
async fn exploit_heartbleed(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!(
        "Simulating Heartbleed exploitation against {}:{}...",
        host, port
    );

    // Connect to target
    match TcpStream::connect((host, port)).await {
        Ok(_) => {
            println!("Connected to target server, checking for Heartbleed vulnerability...");

            // Simulation of Heartbleed test
            println!(
                "{}",
                "SIMULATION ONLY: No actual Heartbleed exploit attempted".bright_yellow()
            );
            println!("In a real scenario, FortiCore would:");
            println!("1. Send a TLS Heartbeat request with manipulated length");
            println!("2. Check if the response contains more data than was sent");
            println!("3. Analyze returned memory for sensitive information");

            println!("\n{}", "Recommendation:".bright_yellow());
            println!("Ensure OpenSSL is updated to version 1.0.1g or later.");
            println!("Run 'openssl version' on the server to check the current version.");

            Ok(())
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Helper function to create a TLS config with weak ciphers
fn create_weak_cipher_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // Add system certificates
    match rustls_native_certs::load_native_certs() {
        Ok(certs) => {
            for cert in certs {
                root_store.add(&rustls::Certificate(cert.0)).map_err(|_| {
                    FortiCoreError::ExploitError("Failed to add root certificate".to_string())
                })?;
            }
        }
        Err(e) => {
            return Err(FortiCoreError::ExploitError(format!(
                "Failed to load system certificates: {}",
                e
            )));
        }
    }

    // Create config manually to include weak ciphers
    let mut config = ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    // This is just a demonstration - in real code we would customize the cipher suites
    // But rustls doesn't support legacy/weak ciphers by design

    Ok(config)
}

// Helper function to create a TLS config that attempts downgrade
fn create_downgrade_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // Add system certificates
    match rustls_native_certs::load_native_certs() {
        Ok(certs) => {
            for cert in certs {
                root_store.add(&rustls::Certificate(cert.0)).map_err(|_| {
                    FortiCoreError::ExploitError("Failed to add root certificate".to_string())
                })?;
            }
        }
        Err(e) => {
            return Err(FortiCoreError::ExploitError(format!(
                "Failed to load system certificates: {}",
                e
            )));
        }
    }

    // Create config with custom protocol versions
    // Note: rustls doesn't actually support SSLv3 or very old TLS versions by design
    let config = ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    Ok(config)
}
