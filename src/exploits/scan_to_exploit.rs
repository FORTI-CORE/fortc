use crate::scanners::Vulnerability;
use crate::utils::error::FortiCoreResult;
use crate::utils::FortiCoreError;
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::path::Path;

// Maps vulnerability IDs to appropriate exploit functions
pub fn get_exploit_mapping() -> HashMap<&'static str, fn(&str, bool, bool) -> FortiCoreResult<()>> {
    let mut mapping = HashMap::new();

    // Helper function to block on a future
    fn run_async<F, T>(future: F) -> T
    where
        F: std::future::Future<Output = T> + Send + 'static,
        T: Send + 'static,
    {
        tokio::task::block_in_place(|| {
            let handle = tokio::runtime::Handle::current();
            handle.block_on(future)
        })
    }

    // Use type annotation for the closure
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(
                async move { super::xss_exploit::exploit(&target_str, safe_mode, verbose).await },
            )
        };
    mapping.insert("WEB-001", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(
                async move { super::sqli_exploit::exploit(&target_str, safe_mode, verbose).await },
            )
        };
    mapping.insert("WEB-002", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(
                async move { super::cors_exploit::exploit(&target_str, safe_mode, verbose).await },
            )
        };
    mapping.insert("WEB-003", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(
                async move { super::xss_exploit::exploit(&target_str, safe_mode, verbose).await },
            )
        };
    mapping.insert("WEB-004", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(
                async move { super::sqli_exploit::exploit(&target_str, safe_mode, verbose).await },
            )
        };
    mapping.insert("WEB-005", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            // Default to WordPress but in a real implementation
            // we would extract CMS type from vulnerability details
            run_async(async move {
                super::cms_exploit::exploit(&target_str, "wordpress", safe_mode, verbose).await
            })
        };
    mapping.insert("WEB-CMS-001", exploit_fn);

    // Network exploits
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-001", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-001", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-002", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-002", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-003", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-003", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-004", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-004", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-005", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-005", exploit_fn);

    // Add mappings for NET-006 (RDP) and NET-007 (SMB)
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-006", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-006", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-007", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-007", exploit_fn);

    // Add mappings for NET-010 to NET-014 (Database exploits)
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-010", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-010", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-011", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-011", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-012", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-012", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-013", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-013", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-014", safe_mode, verbose).await
            })
        };
    mapping.insert("NET-014", exploit_fn);

    // SSL exploits
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::ssl_exploit::exploit(&target_str, "SSL-001", safe_mode, verbose).await
            })
        };
    mapping.insert("SSL-001", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::ssl_exploit::exploit(&target_str, "SSL-002", safe_mode, verbose).await
            })
        };
    mapping.insert("SSL-002", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::ssl_exploit::exploit(&target_str, "SSL-003", safe_mode, verbose).await
            })
        };
    mapping.insert("SSL-003", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::ssl_exploit::exploit(&target_str, "SSL-004", safe_mode, verbose).await
            })
        };
    mapping.insert("SSL-004", exploit_fn);

    // Add mappings for VULN- vulnerabilities
    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-002", safe_mode, verbose).await
            })
        };
    mapping.insert("VULN-FTP-ANON", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-007", safe_mode, verbose).await
            })
        };
    mapping.insert("VULN-SMB-SAMBA", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-011", safe_mode, verbose).await
            })
        };
    mapping.insert("VULN-MYSQL-EXPOSURE", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-012", safe_mode, verbose).await
            })
        };
    mapping.insert("VULN-POSTGRES-EXPOSURE", exploit_fn);

    let exploit_fn: fn(&str, bool, bool) -> FortiCoreResult<()> =
        |target: &str, safe_mode: bool, verbose: bool| {
            let target_str = target.to_string();
            run_async(async move {
                super::network_exploit::exploit(&target_str, "NET-001", safe_mode, verbose).await
            })
        };
    mapping.insert("VULN-BACKDOOR-1524", exploit_fn);

    mapping
}

// Load scan results from a file
pub fn load_scan_results(file_path: &Path) -> FortiCoreResult<Vec<Vulnerability>> {
    let mut file = File::open(file_path).map_err(|e| FortiCoreError::IoError(e))?;

    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| FortiCoreError::IoError(e))?;

    let scan_result: serde_json::Value =
        serde_json::from_str(&contents).map_err(|e| FortiCoreError::SerializationError(e))?;

    // Extract vulnerabilities from the scan results
    if let Some(vulns) = scan_result
        .get("vulnerabilities")
        .and_then(|v| v.as_array())
    {
        let vulnerabilities: Vec<Vulnerability> = serde_json::from_value(vulns.clone().into())
            .map_err(|e| FortiCoreError::SerializationError(e))?;

        Ok(vulnerabilities)
    } else {
        Err(FortiCoreError::InputError(
            "No vulnerabilities found in scan results".to_string(),
        ))
    }
}

// Filter vulnerabilities by exploitability
pub fn get_exploitable_vulnerabilities(vulnerabilities: &[Vulnerability]) -> Vec<&Vulnerability> {
    vulnerabilities.iter().filter(|v| v.exploitable).collect()
}

// Prioritize vulnerabilities by severity
pub fn prioritize_vulnerabilities<'a>(
    vulnerabilities: Vec<&'a Vulnerability>,
) -> Vec<&'a Vulnerability> {
    let mut sorted_vulns = vulnerabilities;
    sorted_vulns.sort_by(|a, b| b.severity.cmp(&a.severity));
    sorted_vulns
}

// Main function to exploit vulnerabilities from scan results
pub async fn exploit_from_scan_results(
    scan_file: &Path,
    target: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    // Load vulnerabilities from scan results
    let vulnerabilities = load_scan_results(scan_file)?;

    if vulnerabilities.is_empty() {
        println!("No vulnerabilities found in scan results");
        return Ok(());
    }

    // Get exploitable vulnerabilities and prioritize them
    let exploitable = get_exploitable_vulnerabilities(&vulnerabilities);

    if exploitable.is_empty() {
        println!("No exploitable vulnerabilities found in scan results");
        return Ok(());
    }

    let prioritized = prioritize_vulnerabilities(exploitable);

    println!("Found {} exploitable vulnerabilities", prioritized.len());

    // Get exploit mapping
    let exploit_mapping = get_exploit_mapping();

    // Attempt to exploit each vulnerability in priority order
    for vuln in prioritized {
        println!("Attempting to exploit: {} ({})", vuln.name, vuln.id);

        if let Some(exploit_fn) = exploit_mapping.get(vuln.id.as_str()) {
            println!("Exploit module found for {}", vuln.id);
            match exploit_fn(target, safe_mode, verbose) {
                Ok(_) => println!("Successfully exploited vulnerability: {}", vuln.id),
                Err(e) => println!("Failed to exploit vulnerability {}: {}", vuln.id, e),
            }
        } else {
            println!("No exploit module available for vulnerability: {}", vuln.id);
        }
    }

    Ok(())
}
