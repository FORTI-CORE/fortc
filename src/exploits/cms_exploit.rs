use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use reqwest::{
    header::{HeaderMap, HeaderValue, USER_AGENT},
    Client,
};
use serde_json::Value;
use url::Url;

pub async fn exploit(
    target: &str,
    cms_type: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!("{}", "Starting CMS Exploitation module...".bright_yellow());

    if !safe_mode {
        println!(
            "{}",
            "Warning: Safe mode is disabled. Running full CMS exploits.".bright_red()
        );
    }

    // Normalize URL
    let target_url = normalize_url(target);
    let parsed_url = Url::parse(&target_url)
        .map_err(|e| FortiCoreError::InputError(format!("Invalid URL format: {}", e)))?;

    if verbose {
        println!("Targeting URL: {}", target_url);
        println!("CMS Type: {}", cms_type);
    }

    // Create HTTP client with appropriate headers
    let client = create_client()?;

    println!("{}", "Phase 1: Verifying CMS presence...".bright_blue());

    match cms_type.to_lowercase().as_str() {
        "wordpress" => exploit_wordpress(&client, &target_url, safe_mode, verbose).await?,
        "drupal" => exploit_drupal(&client, &target_url, safe_mode, verbose).await?,
        "joomla" => exploit_joomla(&client, &target_url, safe_mode, verbose).await?,
        "magento" => exploit_magento(&client, &target_url, safe_mode, verbose).await?,
        _ => {
            println!(
                "Unsupported CMS type: {}. Attempting generic CMS exploitation.",
                cms_type
            );
            exploit_generic_cms(&client, &target_url, cms_type, safe_mode, verbose).await?
        }
    }

    // Provide remediation guidance
    println!("\n{}", "Remediation recommendations:".bright_yellow());
    println!("1. Keep your CMS and all plugins/themes updated to the latest version");
    println!("2. Remove unnecessary plugins and themes");
    println!("3. Implement proper access controls and user permissions");
    println!("4. Use a Web Application Firewall (WAF)");
    println!("5. Enable security plugins specific to your CMS");
    println!("6. Regularly backup your CMS and database");
    println!("7. Implement HTTPS with proper configuration");
    println!("8. Use strong passwords and 2FA where available");

    Ok(())
}

async fn exploit_wordpress(
    client: &Client,
    url: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!("{}", "Exploiting WordPress CMS...".bright_blue());

    // Check common WordPress paths to confirm it's WordPress
    let wp_paths = [
        "/wp-login.php",
        "/wp-admin/",
        "/wp-content/",
        "/wp-includes/",
    ];

    let mut confirmed = false;
    for path in &wp_paths {
        let test_url = format!("{}{}", url.trim_end_matches('/'), path);
        if verbose {
            println!("Testing path: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success() {
                println!("Found WordPress path: {}", test_url);
                confirmed = true;
                break;
            }
        }
    }

    if !confirmed {
        println!("Could not confirm WordPress installation. Aborting.");
        return Ok(());
    }

    // Look for WordPress version
    println!(
        "{}",
        "Attempting to identify WordPress version...".bright_blue()
    );
    let version = identify_wordpress_version(client, url).await?;

    if let Some(ver) = version {
        println!("Detected WordPress version: {}", ver);

        // Check for known vulnerabilities based on version
        println!("{}", "Checking for known vulnerabilities...".bright_blue());
        let vulnerabilities = get_wordpress_vulnerabilities(&ver);

        if !vulnerabilities.is_empty() {
            println!("{}", "Found vulnerabilities:".bright_red());
            for vuln in vulnerabilities {
                println!("- {}: {}", vuln.0, vuln.1);
            }

            if !safe_mode {
                println!(
                    "{}",
                    "Attempting to exploit vulnerabilities...".bright_red()
                );
                println!("Exploitation would be performed here in non-safe mode");
            }
        } else {
            println!("No known vulnerabilities found for this version.");
        }
    } else {
        println!("Could not determine WordPress version.");
    }

    // Test for username enumeration
    println!("{}", "Testing for username enumeration...".bright_blue());
    let usernames = enumerate_wordpress_users(client, url).await?;

    if !usernames.is_empty() {
        println!("{}", "Successfully enumerated usernames:".bright_red());
        for user in usernames {
            println!("- {}", user);
        }
    }

    Ok(())
}

async fn exploit_drupal(
    client: &Client,
    url: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!("{}", "Exploiting Drupal CMS...".bright_blue());

    // Basic checks for Drupal
    let drupal_paths = ["/core/", "/sites/default/", "/admin/", "/user/login"];

    let mut confirmed = false;
    for path in &drupal_paths {
        let test_url = format!("{}{}", url.trim_end_matches('/'), path);
        if verbose {
            println!("Testing path: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success() {
                println!("Found Drupal path: {}", test_url);
                confirmed = true;
                break;
            }
        }
    }

    if !confirmed {
        println!("Could not confirm Drupal installation. Aborting.");
        return Ok(());
    }

    // Look for Drupal version
    println!(
        "{}",
        "Attempting to identify Drupal version...".bright_blue()
    );

    // For demonstration purposes - in a real exploit we would implement full version detection
    println!("Version detection would be implemented here");

    if !safe_mode {
        println!(
            "{}",
            "Attempting to exploit vulnerabilities...".bright_red()
        );
        println!("Exploitation would be performed here in non-safe mode");
    }

    Ok(())
}

async fn exploit_joomla(
    client: &Client,
    url: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!("{}", "Exploiting Joomla CMS...".bright_blue());

    // Basic checks for Joomla
    let joomla_paths = [
        "/administrator/",
        "/components/",
        "/modules/",
        "/templates/",
    ];

    let mut confirmed = false;
    for path in &joomla_paths {
        let test_url = format!("{}{}", url.trim_end_matches('/'), path);
        if verbose {
            println!("Testing path: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success() {
                println!("Found Joomla path: {}", test_url);
                confirmed = true;
                break;
            }
        }
    }

    if !confirmed {
        println!("Could not confirm Joomla installation. Aborting.");
        return Ok(());
    }

    // Look for Joomla version
    println!(
        "{}",
        "Attempting to identify Joomla version...".bright_blue()
    );

    // For demonstration purposes - in a real exploit we would implement full version detection
    println!("Version detection would be implemented here");

    if !safe_mode {
        println!(
            "{}",
            "Attempting to exploit vulnerabilities...".bright_red()
        );
        println!("Exploitation would be performed here in non-safe mode");
    }

    Ok(())
}

async fn exploit_magento(
    client: &Client,
    url: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!("{}", "Exploiting Magento CMS...".bright_blue());

    // Basic checks for Magento
    let magento_paths = ["/admin/", "/app/etc/", "/skin/", "/js/mage/"];

    let mut confirmed = false;
    for path in &magento_paths {
        let test_url = format!("{}{}", url.trim_end_matches('/'), path);
        if verbose {
            println!("Testing path: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success() {
                println!("Found Magento path: {}", test_url);
                confirmed = true;
                break;
            }
        }
    }

    if !confirmed {
        println!("Could not confirm Magento installation. Aborting.");
        return Ok(());
    }

    // Look for Magento version
    println!(
        "{}",
        "Attempting to identify Magento version...".bright_blue()
    );

    // For demonstration purposes - in a real exploit we would implement full version detection
    println!("Version detection would be implemented here");

    if !safe_mode {
        println!(
            "{}",
            "Attempting to exploit vulnerabilities...".bright_red()
        );
        println!("Exploitation would be performed here in non-safe mode");
    }

    Ok(())
}

async fn exploit_generic_cms(
    client: &Client,
    url: &str,
    cms_type: &str,
    safe_mode: bool,
    verbose: bool,
) -> FortiCoreResult<()> {
    println!(
        "{}",
        format!("Generic exploitation of {} CMS...", cms_type).bright_blue()
    );

    println!("Checking for common vulnerabilities in CMS platforms...");

    // Test for common vulnerabilities across CMS platforms

    // 1. Check for admin pages
    let admin_paths = [
        "/admin/",
        "/administrator/",
        "/wp-admin/",
        "/control-panel/",
        "/cms/admin/",
        "/admin-console/",
        "/backoffice/",
        "/manage/",
    ];

    for path in &admin_paths {
        let test_url = format!("{}{}", url.trim_end_matches('/'), path);
        if verbose {
            println!("Testing admin path: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success()
                || response.status().as_u16() == 401
                || response.status().as_u16() == 403
            {
                println!("Found potential admin interface: {}", test_url);
            }
        }
    }

    // 2. Check for backup files
    let backup_extensions = [".bak", ".old", ".backup", ".zip", ".tar.gz", ".sql"];

    for ext in &backup_extensions {
        let test_url = format!("{}/config{}", url.trim_end_matches('/'), ext);
        if verbose {
            println!("Testing backup file: {}", test_url);
        }

        let resp = client.get(&test_url).send().await;
        if let Ok(response) = resp {
            if response.status().is_success() {
                println!(
                    "{}",
                    format!("Found potential backup file: {}", test_url).bright_red()
                );
            }
        }
    }

    if !safe_mode {
        println!(
            "{}",
            "Attempting to exploit generic CMS vulnerabilities...".bright_red()
        );
        println!("Exploitation would be performed here in non-safe mode");
    }

    Ok(())
}

async fn identify_wordpress_version(client: &Client, url: &str) -> FortiCoreResult<Option<String>> {
    // First check the generator meta tag
    let resp = client.get(url).send().await.map_err(|e| {
        FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
    })?;

    let body = resp
        .text()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to read response: {}", e)))?;

    // Look for generator meta tag
    let re = regex::Regex::new(
        r#"<meta\s+name=["']generator["']\s+content=["']WordPress\s+([\d\.]+)["']"#,
    )
    .unwrap();
    if let Some(caps) = re.captures(&body) {
        if let Some(version) = caps.get(1) {
            return Ok(Some(version.as_str().to_string()));
        }
    }

    // Check readme.html
    let readme_url = format!("{}/readme.html", url.trim_end_matches('/'));
    let resp = client.get(&readme_url).send().await;

    if let Ok(response) = resp {
        if response.status().is_success() {
            let body = response.text().await.map_err(|e| {
                FortiCoreError::NetworkError(format!("Failed to read response: {}", e))
            })?;

            let re = regex::Regex::new(r#">Version ([\d\.]+)<"#).unwrap();
            if let Some(caps) = re.captures(&body) {
                if let Some(version) = caps.get(1) {
                    return Ok(Some(version.as_str().to_string()));
                }
            }
        }
    }

    // Check feed URL
    let feed_url = format!("{}/feed/", url.trim_end_matches('/'));
    let resp = client.get(&feed_url).send().await;

    if let Ok(response) = resp {
        if response.status().is_success() {
            let body = response.text().await.map_err(|e| {
                FortiCoreError::NetworkError(format!("Failed to read response: {}", e))
            })?;

            let re =
                regex::Regex::new(r#"<generator>https://wordpress.org/\?v=([\d\.]+)</generator>"#)
                    .unwrap();
            if let Some(caps) = re.captures(&body) {
                if let Some(version) = caps.get(1) {
                    return Ok(Some(version.as_str().to_string()));
                }
            }
        }
    }

    Ok(None)
}

fn get_wordpress_vulnerabilities(version: &str) -> Vec<(String, String)> {
    // This would normally query a vulnerability database or have a built-in list
    // For demonstration purposes, we'll return some example vulnerabilities
    let major_version = version.split('.').next().unwrap_or("0");
    let minor_version = version.split('.').nth(1).unwrap_or("0");

    let major = major_version.parse::<u32>().unwrap_or(0);
    let minor = minor_version.parse::<u32>().unwrap_or(0);

    let mut vulnerabilities = Vec::new();

    // Example vulnerabilities for demonstration
    if major < 5 {
        vulnerabilities.push((
            "CVE-2019-8942".to_string(),
            "Unauthenticated remote code execution in WordPress < 5.0.1".to_string(),
        ));
    }

    if major == 5 && minor < 4 {
        vulnerabilities.push((
            "CVE-2019-16223".to_string(),
            "WordPress < 5.4.0 stored XSS vulnerability".to_string(),
        ));
    }

    if major < 5 || (major == 5 && minor < 2) {
        vulnerabilities.push((
            "CVE-2019-16219".to_string(),
            "WordPress < 5.2.3 URL sanitization vulnerability".to_string(),
        ));
    }

    vulnerabilities
}

async fn enumerate_wordpress_users(client: &Client, url: &str) -> FortiCoreResult<Vec<String>> {
    let mut usernames = Vec::new();

    // Method 1: Author archive pages
    for i in 1..5 {
        // Try first few user IDs
        let author_url = format!("{}/author/{}/", url.trim_end_matches('/'), i);
        let resp = client.get(&author_url).send().await;

        if let Ok(response) = resp {
            if response.status().is_success() {
                let body = response.text().await.map_err(|e| {
                    FortiCoreError::NetworkError(format!("Failed to read response: {}", e))
                })?;

                // Extract author name
                let re = regex::Regex::new(r#"<title>([^<>]+) - "#).unwrap();
                if let Some(caps) = re.captures(&body) {
                    if let Some(author) = caps.get(1) {
                        usernames.push(author.as_str().to_string());
                    }
                }
            }
        }
    }

    // Method 2: REST API user endpoint
    let rest_url = format!("{}/wp-json/wp/v2/users/", url.trim_end_matches('/'));
    let resp = client.get(&rest_url).send().await;

    if let Ok(response) = resp {
        if response.status().is_success() {
            let body = response.text().await.map_err(|e| {
                FortiCoreError::NetworkError(format!("Failed to read response: {}", e))
            })?;

            if let Ok(json) = serde_json::from_str::<Vec<Value>>(&body) {
                for user in json {
                    if let Some(name) = user.get("name").and_then(Value::as_str) {
                        if !usernames.contains(&name.to_string()) {
                            usernames.push(name.to_string());
                        }
                    }
                }
            }
        }
    }

    Ok(usernames)
}

fn normalize_url(url: &str) -> String {
    if !url.starts_with("http://") && !url.starts_with("https://") {
        format!("http://{}", url)
    } else {
        url.to_string()
    }
}

fn create_client() -> FortiCoreResult<Client> {
    let mut headers = HeaderMap::new();
    headers.insert(
        USER_AGENT,
        HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) FortiCore/0.1.0"),
    );

    let client = Client::builder()
        .default_headers(headers)
        .timeout(std::time::Duration::from_secs(15))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    Ok(client)
}
